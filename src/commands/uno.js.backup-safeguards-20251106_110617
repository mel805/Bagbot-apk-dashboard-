const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, AttachmentBuilder } = require('discord.js');
const path = require('path');
const { createCanvas, loadImage } = require('canvas');
const fs = require('fs');

// Mapping des emojis custom de cartes UNO (Application Emojis)
const EMOJI_MAP = {
  'uno_r0': '<:uno_r0:1433191075945779401>',
  'uno_r1': '<:uno_r1:1433191080567767062>',
  'uno_r2': '<:uno_r2:1433191085030641879>',
  'uno_r3': '<:uno_r3:1433191089107505315>',
  'uno_r4': '<:uno_r4:1433191093520040113>',
  'uno_r5': '<:uno_r5:1433191105091997696>',
  'uno_r6': '<:uno_r6:1433191109672177737>',
  'uno_r7': '<:uno_r7:1433191114504146945>',
  'uno_r8': '<:uno_r8:1433191118698319934>',
  'uno_r9': '<:uno_r9:1433191123299471443>',
  'uno_rskip': '<:uno_rskip:1433193235043319878>',
  'uno_rrev': '<:uno_rrev:1433194079927406663>',
  'uno_rp2': '<:uno_rp2:1433193252194095286>',
  'uno_b0': '<:uno_b0:1433191141376786577>',
  'uno_b1': '<:uno_b1:1433191146179264542>',
  'uno_b2': '<:uno_b2:1433191150436749439>',
  'uno_b3': '<:uno_b3:1433191154857279632>',
  'uno_b4': '<:uno_b4:1433191160167534774>',
  'uno_b5': '<:uno_b5:1433191165036859483>',
  'uno_b6': '<:uno_b6:1433191169285685362>',
  'uno_b7': '<:uno_b7:1433191174054613195>',
  'uno_b8': '<:uno_b8:1433191178676867124>',
  'uno_b9': '<:uno_b9:1433191183470825655>',
  'uno_bskip': '<:uno_bskip:1433193260691493085>',
  'uno_brev': '<:uno_brev:1433194088252838060>',
  'uno_bp2': '<:uno_bp2:1433193277284159651>',
  'uno_g0': '<:uno_g0:1433191202160640152>',
  'uno_g1': '<:uno_g1:1433191206363598939>',
  'uno_g2': '<:uno_g2:1433191211040116897>',
  'uno_g3': '<:uno_g3:1433191215565639830>',
  'uno_g4': '<:uno_g4:1433191220284493864>',
  'uno_g5': '<:uno_g5:1433191224751427595>',
  'uno_g6': '<:uno_g6:1433191229537124372>',
  'uno_g7': '<:uno_g7:1433191234104590518>',
  'uno_g8': '<:uno_g8:1433191238617534596>',
  'uno_g9': '<:uno_g9:1433191243822665749>',
  'uno_gskip': '<:uno_gskip:1433193285450465494>',
  'uno_grev': '<:uno_grev:1433194096327000167>',
  'uno_gp2': '<:uno_gp2:1433193303997808764>',
  'uno_y0': '<:uno_y0:1433191262227267696>',
  'uno_y1': '<:uno_y1:1433191266744664185>',
  'uno_y2': '<:uno_y2:1433191271219990598>',
  'uno_y3': '<:uno_y3:1433191275602907136>',
  'uno_y4': '<:uno_y4:1433191279696675040>',
  'uno_y5': '<:uno_y5:1433191284335575133>',
  'uno_y6': '<:uno_y6:1433191289620402267>',
  'uno_y7': '<:uno_y7:1433191294188126300>',
  'uno_y8': '<:uno_y8:1433191298747072644>',
  'uno_y9': '<:uno_y9:1433191303348359271>',
  'uno_yskip': '<:uno_yskip:1433193312336089108>',
  'uno_yrev': '<:uno_yrev:1433194105017733150>',
  'uno_yp2': '<:uno_yp2:1433193328903458937>',
  'uno_wild': '<:uno_wild:1433194845153005568>',
  'uno_wildp4': '<:uno_wildp4:1433194853495345263>',
};

// Fonction pour obtenir le chemin de l'image d'une carte
function getCardImagePath(card) {
  const color = card.chosenColor || card.color;
  const colorPrefix = { red: 'r', blue: 'b', green: 'g', yellow: 'y' };
  
  let filename = '';
  
  if (card.type === 'number') {
    filename = `uno_${colorPrefix[color]}${card.value}.png`;
  } else if (card.type === 'skip') {
    filename = `uno_${colorPrefix[color]}skip.png`;
  } else if (card.type === 'reverse') {
    filename = `uno_${colorPrefix[color]}rev.png`;
  } else if (card.type === 'draw2') {
    filename = `uno_${colorPrefix[color]}p2.png`;
  } else if (card.type === 'wild') {
    filename = 'uno_wild.png';
  } else if (card.type === 'wild_draw4') {
    filename = 'uno_wildp4.png';
  }
  
  return path.join(__dirname, '..', '..', 'uno-cards', filename);
}

// Fonction pour cr√©er une image composite de la main d'un joueur
async function createHandImage(cards) {
  const cardWidth = 400;
  const cardHeight = 600;
  const cardsPerRow = 4;
  const rows = Math.ceil(cards.length / cardsPerRow);
  const padding = 20;
  
  const canvasWidth = (cardWidth + padding) * Math.min(cardsPerRow, cards.length) + padding;
  const canvasHeight = (cardHeight + padding) * rows + padding;
  
  const canvas = createCanvas(canvasWidth, canvasHeight);
  const ctx = canvas.getContext('2d');
  
  // Fond transparent/sombre
  ctx.fillStyle = '#2C2F33';
  ctx.fillRect(0, 0, canvasWidth, canvasHeight);
  
  // Charger et dessiner chaque carte
  for (let i = 0; i < cards.length; i++) {
    const card = cards[i];
    const cardPath = getCardImagePath(card);
    
    if (fs.existsSync(cardPath)) {
      const image = await loadImage(cardPath);
      const row = Math.floor(i / cardsPerRow);
      const col = i % cardsPerRow;
      const x = padding + col * (cardWidth + padding);
      const y = padding + row * (cardHeight + padding);
      
      ctx.drawImage(image, x, y, cardWidth, cardHeight);
      
      // Num√©ro de la carte
      ctx.fillStyle = '#FFFFFF';
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 4;
      ctx.font = 'bold 60px Arial';
      ctx.strokeText(`${i + 1}`, x + 30, y + 70);
      ctx.fillText(`${i + 1}`, x + 30, y + 70);
    }
  }
  
  return canvas.toBuffer('image/png');
}

// Fonction pour obtenir l'emoji custom de carte UNO
function getCardVisual(card) {
  const color = card.chosenColor || card.color;
  const colorPrefix = { red: 'r', blue: 'b', green: 'g', yellow: 'y' };
  
  let emojiKey = '';
  
  if (card.type === 'number') {
    emojiKey = `uno_${colorPrefix[color]}${card.value}`;
  } else if (card.type === 'skip') {
    emojiKey = `uno_${colorPrefix[color]}skip`;
  } else if (card.type === 'reverse') {
    emojiKey = `uno_${colorPrefix[color]}rev`;
  } else if (card.type === 'draw2') {
    emojiKey = `uno_${colorPrefix[color]}p2`;
  } else if (card.type === 'wild') {
    emojiKey = 'uno_wild';
  } else if (card.type === 'wild_draw4') {
    emojiKey = 'uno_wildp4';
  }
  
  return EMOJI_MAP[emojiKey] || '‚ùì';
}

// Stockage des parties en cours
const activeGames = new Map();


// ============================================================
// ü§ñ ROBOT IA pour mode solo
// ============================================================
async function playBotTurn(game, message) {
  // Attendre 2 secondes pour simuler la r√©flexion
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  const botPlayer = game.players.find(p => p.id === 'UNO_BOT_AI');
  if (!botPlayer) return;
  
  const currentPlayer = game.getCurrentPlayer();
  if (currentPlayer.id !== 'UNO_BOT_AI') return;
  
  // Strat√©gie du bot: jouer la premi√®re carte valide
  let cardPlayed = false;
  
  for (let i = 0; i < botPlayer.hand.length; i++) {
    const card = botPlayer.hand[i];
    const topCard = game.discardPile[game.discardPile.length - 1];
    
    // V√©rifier si la carte peut √™tre jou√©e
    if (card.type === 'wild' || card.type === 'wild_draw4') {
      // Joker: choisir la couleur la plus pr√©sente dans la main
      const colors = { red: 0, blue: 0, green: 0, yellow: 0 };
      botPlayer.hand.forEach(c => {
        if (c.color && c.color !== 'wild') colors[c.color]++;
      });
      const bestColor = Object.keys(colors).reduce((a, b) => colors[a] > colors[b] ? a : b);
      
      const result = game.playCard('UNO_BOT_AI', i, bestColor);
      if (result.success) {
        cardPlayed = true;
        console.log(`[UNO BOT] Joue ${game.getCardDisplay(card)} (joker ‚Üí ${bestColor})`);
        
        if (result.winner) {
          activeGames.delete(game.channelId);
          const winEmbed = new EmbedBuilder().setColor('#FFD700').setTitle('üéâ VICTOIRE !').setDescription('ü§ñ Le Robot a gagn√© !\n\nR√©essayez !');
          return message.edit({ embeds: [winEmbed], components: [], files: [] });
        }
        break;
      }
    } else if (card.color === topCard.color || 
               card.value === topCard.value || 
               card.type === topCard.type) {
      const result = game.playCard('UNO_BOT_AI', i);
      if (result.success) {
        cardPlayed = true;
        console.log(`[UNO BOT] Joue ${game.getCardDisplay(card)}`);
        
        if (result.winner) {
          activeGames.delete(game.channelId);
          const winEmbed = new EmbedBuilder().setColor('#FFD700').setTitle('üéâ VICTOIRE !').setDescription('ü§ñ Le Robot a gagn√© !\n\nR√©essayez !');
          return message.edit({ embeds: [winEmbed], components: [], files: [] });
        }
        break;
      }
    }
  }
  
  // Si aucune carte n'a pu √™tre jou√©e, piocher
  if (!cardPlayed) {
    // Si drawCount > 0 (p√©nalit√© +2/+4), piocher toutes les cartes
    if (game.drawCount > 0) {
      const drawnCards = [];
      for (let idx = 0; idx < game.drawCount; idx++) {
        const card = game.drawCard(botPlayer);
        if (card) drawnCards.push(game.getCardDisplay(card));
      }
      console.log(`[UNO BOT] Pioche p√©nalit√©: ${game.drawCount} carte(s) - ${drawnCards.join(' ')}`);
      game.drawCount = 0; // R√©initialiser le compteur
    } else {
      // Pioche normale (1 carte)
      const card = game.drawCard(botPlayer);
      console.log(`[UNO BOT] Pioche: ${game.getCardDisplay(card)}`);
    }
    game.nextPlayer();
  }
  
  // Mettre √† jour l'affichage
  const { embed: gameEmbed, attachment } = game.createGameEmbed();
  const actionButtons = game.createActionButtons();
  await message.edit({ embeds: [gameEmbed], files: [attachment], components: [actionButtons] });
  // Si mode solo et c'est le tour du bot, le faire jouer
  if (game.isSoloMode) {
    setTimeout(async () => {
      const currentPlayer = game.getCurrentPlayer();
      if (currentPlayer && currentPlayer.id === 'UNO_BOT_AI') {
        await playBotTurn(game, message);
      }
    }, 1000);
  }
  
  // Si c'est encore au tour du bot (apr√®s un +2/+4), rejouer
  const newCurrentPlayer = game.getCurrentPlayer();
  if (newCurrentPlayer.id === 'UNO_BOT_AI') {
    await playBotTurn(game, message);
  }
}

class UnoGame {
  constructor(channelId, creatorId) {
    this.channelId = channelId;
    this.creatorId = creatorId;
    this.players = [];
    this.deck = [];
    this.discardPile = [];
    this.currentPlayerIndex = 0;
    this.direction = 1;
    this.started = false;
    this.drawCount = 0;
    this.messageId = null;
    this.collector = null;
    this.handCollectors = new Map(); // Store hand collectors per player
  }

  addPlayer(userId, username) {
    if (this.started) return false;
    if (this.players.find(p => p.id === userId)) return false;
    if (this.players.length >= 10) return false;
    
    this.players.push({
      id: userId,
      username: username,
      hand: []
    });
    return true;
  }

  removePlayer(userId) {
    const index = this.players.findIndex(p => p.id === userId);
    if (index === -1) return false;
    
    this.players.splice(index, 1);
    
    if (this.currentPlayerIndex >= this.players.length) {
      this.currentPlayerIndex = 0;
    }
    
    return true;
  }

  createDeck() {
    this.deck = [];
    const colors = ['red', 'blue', 'green', 'yellow'];
    
    for (const color of colors) {
      this.deck.push({ type: 'number', color, value: 0 });
      for (let i = 1; i <= 9; i++) {
        this.deck.push({ type: 'number', color, value: i });
        this.deck.push({ type: 'number', color, value: i });
      }
    }
    
    for (const color of colors) {
      for (let i = 0; i < 2; i++) {
        this.deck.push({ type: 'skip', color });
        this.deck.push({ type: 'reverse', color });
        this.deck.push({ type: 'draw2', color });
      }
    }
    
    for (let i = 0; i < 4; i++) {
      this.deck.push({ type: 'wild', color: null });
      this.deck.push({ type: 'wild_draw4', color: null });
    }
    
    this.shuffle(this.deck);
  }

  shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
  }

  dealCards() {
    for (const player of this.players) {
      player.hand = [];
      for (let i = 0; i < 7; i++) {
        player.hand.push(this.deck.pop());
      }
    }
    
    let startCard;
    do {
      startCard = this.deck.pop();
    } while (startCard.type !== 'number');
    
    this.discardPile.push(startCard);
  }

  drawCard(player) {
    if (this.deck.length === 0) {
      const topCard = this.discardPile.pop();
      this.deck = [...this.discardPile];
      this.shuffle(this.deck);
      this.discardPile = [topCard];
    }
    
    if (this.deck.length > 0) {
      const card = this.deck.pop();
      player.hand.push(card);
      return card;
    }
    return null;
  }

  canPlayCard(card, topCard) {
    if (card.type === 'wild' || card.type === 'wild_draw4') return true;
    if (card.color === topCard.color) return true;
    
    const topColor = topCard.chosenColor || topCard.color;
    if (card.color === topColor) return true;
    
    if (card.type === 'number' && topCard.type === 'number' && card.value === topCard.value) return true;
    if (card.type === topCard.type && card.type !== 'number') return true;
    
    return false;
  }

  playCard(playerId, cardIndex, chosenColor = null) {
    const player = this.players[this.currentPlayerIndex];
    if (player.id !== playerId) return { success: false, error: "Ce n est pas votre tour !" };
    
    if (cardIndex < 0 || cardIndex >= player.hand.length) {
      return { success: false, error: "Carte invalide !" };
    }
    
    const card = player.hand[cardIndex];
    const topCard = this.discardPile[this.discardPile.length - 1];
    
    // Si drawCount > 0, on ne peut jouer que +2 ou +4 pour cumuler
    if (this.drawCount > 0) {
      if (card.type !== 'draw2' && card.type !== 'wild_draw4') {
        return { success: false, error: `Vous devez piocher ${this.drawCount} carte(s) ou jouer un +2/+4 !` };
      }
    }
    
    if (!this.canPlayCard(card, topCard)) {
      return { success: false, error: "Cette carte ne peut pas etre jouee !" };
    }
    
    if ((card.type === 'wild' || card.type === 'wild_draw4') && !chosenColor) {
      return { success: false, error: "Vous devez choisir une couleur !", requireColor: true };
    }
    
    player.hand.splice(cardIndex, 1);
    
    if (chosenColor) {
      card.chosenColor = chosenColor;
    }
    
    this.discardPile.push(card);
    
    if (player.hand.length === 0) {
      return { success: true, winner: player };
    }
    
    let skipNext = false;
    
    switch (card.type) {
      case 'skip':
        skipNext = true;
        break;
      
      case 'reverse':
        if (this.players.length === 2) {
          skipNext = true;
        } else {
          this.direction *= -1;
        }
        break;
      
      case 'draw2':
        this.drawCount += 2;
        skipNext = true;
        break;
      
      case 'wild_draw4':
        this.drawCount += 4;
        skipNext = true;
        break;
    }
    
    this.nextPlayer(skipNext);
    
    return { success: true };
  }

  nextPlayer(skip = false) {
    this.currentPlayerIndex += this.direction;
    
    if (this.currentPlayerIndex >= this.players.length) {
      this.currentPlayerIndex = 0;
    } else if (this.currentPlayerIndex < 0) {
      this.currentPlayerIndex = this.players.length - 1;
    }
    
    // Si skip et drawCount = 0, on passe encore au suivant
    if (skip && this.drawCount === 0) {
      this.nextPlayer(false);
    }
    // Si drawCount > 0, on NE passe PAS au suivant : le joueur doit piocher
  }

  getCardDisplay(card) {
    return getCardVisual(card);
  }

  getCurrentPlayer() {
    return this.players[this.currentPlayerIndex];
  }

  getTopCard() {
    return this.discardPile[this.discardPile.length - 1];
  }

  createGameEmbed() {
    const topCard = this.getTopCard();
    const currentPlayer = this.getCurrentPlayer();
    
    // Liste compacte des joueurs
    const playersList = this.players.map((p, i) => {
      const indicator = i === this.currentPlayerIndex ? "‚ñ∂" : "‚Ä¢";
      return `${indicator} ${p.username} (${p.hand.length})`;
    }).join("\n");
    
    const cardImagePath = getCardImagePath(topCard);
    const attachment = new AttachmentBuilder(cardImagePath, { name: 'current_card.png' });
    
    let description = `**Tour:** <@${currentPlayer.id}>`;
    if (this.drawCount > 0) {
      description += `\n‚ö†Ô∏è **${this.drawCount} carte(s) √† piocher**`;
    }
    
    // Sens + Pioche sur une ligne
    const sensIcon = this.direction === 1 ? "üîΩ" : "üîº";
    const infosLine = `${sensIcon} Sens ${this.direction === 1 ? "‚Üì" : "‚Üë"}  ‚Ä¢  üìö ${this.deck.length} cartes`;
    
    const embed = new EmbedBuilder()
      .setColor(this.drawCount > 0 ? "#FF0000" : "#FF5500")
      .setTitle("üéÆ UNO")
      .setDescription(description)
      .addFields(
        { name: "üë• Joueurs", value: playersList, inline: false },
        { name: "‚ÑπÔ∏è Infos", value: infosLine, inline: false }
      )
      .setImage('attachment://current_card.png')
      .setFooter({ text: this.drawCount > 0 ? "Piochez ou jouez +2/+4" : "Cliquez sur Ma main" });
    return { embed, attachment };
  }

  createActionButtons() {
    const row = new ActionRowBuilder()
      .addComponents(
        new ButtonBuilder()
          .setCustomId("uno_hand")
          .setLabel("üÉè Ma main")
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId("uno_draw")
          .setLabel("üé¥ Piocher")
          .setStyle(ButtonStyle.Secondary),
        new ButtonBuilder()
          .setCustomId("uno_quit")
          .setLabel("üö™ Quitter")
          .setStyle(ButtonStyle.Danger)
      );
    return row;
  }
}

module.exports = {
  name: "uno",
  data: new SlashCommandBuilder()
    .setName("uno")
    .setDescription("Jouer au UNO avec de vraies cartes !"),

  async execute(interaction) {
    const channelId = interaction.channelId;
    // Defer reply imm√©diatement pour √©viter timeout
    await interaction.deferReply().catch(() => {});

    
    if (activeGames.has(channelId)) {
      return interaction.editReply({ content: "‚ùå Une partie est deja en cours !", flags: (1 << 6) });
    }
    
    const game = new UnoGame(channelId, interaction.user.id);
    game.addPlayer(interaction.user.id, interaction.user.username);
    activeGames.set(channelId, game);
    
    const lobbyEmbed = new EmbedBuilder()
      .setColor("#00FF00")
      .setTitle("üéÆ Nouvelle Partie UNO")
      .setDescription(`${interaction.user.username} a cree une partie !\n\n**Cliquez sur "Rejoindre"**\n*Minimum 2 joueurs*`)
      .addFields({ name: "üë• Joueurs (1/10)", value: `1Ô∏è‚É£ ${interaction.user.username}` })
      .setFooter({ text: "Le createur peut demarrer la partie" });
    
    const lobbyButtons = new ActionRowBuilder()
      .addComponents(
        new ButtonBuilder().setCustomId("uno_join").setLabel("‚úÖ Rejoindre").setStyle(ButtonStyle.Success),
        new ButtonBuilder().setCustomId("uno_solo").setLabel("ü§ñ Solo vs Robot").setStyle(ButtonStyle.Secondary),
        new ButtonBuilder().setCustomId("uno_start").setLabel("üöÄ Demarrer").setStyle(ButtonStyle.Primary),
        new ButtonBuilder().setCustomId("uno_cancel").setLabel("‚ùå Annuler").setStyle(ButtonStyle.Danger)
      );
    
    const message = await interaction.editReply({ embeds: [lobbyEmbed], components: [lobbyButtons], fetchReply: true });
    game.messageId = message.id;
    
    const collector = message.createMessageComponentCollector({ time: 0 });
    game.collector = collector;
    
    collector.on("collect", async i => {
      if (i.customId === "uno_join") {
        const success = game.addPlayer(i.user.id, i.user.username);
        if (!success) {
          if (game.started) return i.reply({ content: "‚ùå Partie commencee !", flags: (1 << 6) });
          if (game.players.find(p => p.id === i.user.id)) return i.reply({ content: "‚ùå Deja dans la partie !", flags: (1 << 6) });
          return i.reply({ content: "‚ùå Partie pleine !", flags: (1 << 6) });
        }
        const numbers = ["1Ô∏è‚É£","2Ô∏è‚É£","3Ô∏è‚É£","4Ô∏è‚É£","5Ô∏è‚É£","6Ô∏è‚É£","7Ô∏è‚É£","8Ô∏è‚É£","9Ô∏è‚É£","üîü"];
        const playerList = game.players.map((p, idx) => `${numbers[idx]} ${p.username}`).join("\n");
        lobbyEmbed.spliceFields(0, 1, { name: `üë• Joueurs (${game.players.length}/10)`, value: playerList });
        await i.update({ embeds: [lobbyEmbed], components: [lobbyButtons] });
      } else if (i.customId === "uno_solo") {
        // Mode Solo vs Robot
        game.addPlayer('UNO_BOT_AI', 'ü§ñ Robot UNO');
        game.isSoloMode = true; // Marquer comme mode solo
        
        // D√©marrer automatiquement avec 2 joueurs (user + bot)
        game.started = true;
        game.createDeck();
        game.dealCards();
        const { embed: gameEmbed, attachment } = game.createGameEmbed();
        const actionButtons = game.createActionButtons();
        await i.update({ embeds: [gameEmbed], files: [attachment], components: [actionButtons] });
        
        collector.stop();
        
        // Lancer le gameCollector pour le mode solo
        setupGameCollectorForSolo(message, game, channelId);
      } else if (i.customId === "uno_start") {
        if (game.creatorId !== i.user.id) return i.reply({ content: "‚ùå Seul le createur peut demarrer !", flags: (1 << 6) });
        if (game.players.length < 2) return i.reply({ content: "‚ùå Minimum 2 joueurs !", flags: (1 << 6) });
        game.started = true;
        game.createDeck();
        game.dealCards();
        const { embed: gameEmbed, attachment } = game.createGameEmbed();
        const actionButtons = game.createActionButtons();
        await i.update({ embeds: [gameEmbed], files: [attachment], components: [actionButtons] });
        setupGameCollector(message, game, channelId);
      } else if (i.customId === "uno_cancel") {
        if (game.creatorId !== i.user.id) return i.reply({ content: "‚ùå Seul le createur peut annuler !", flags: (1 << 6) });
                cleanupGameCollectors(game);
        activeGames.delete(channelId);
        collector.stop();
        await i.update({ content: "üõë Partie annulee.", embeds: [], components: [] });
      }
    });
    
    collector.on("end", () => {
      if (activeGames.has(channelId) && !activeGames.get(channelId).started) {
                cleanupGameCollectors(game);
        activeGames.delete(channelId);
      }
    });
  }
};


// Setup pour mode Solo vs Robot
function setupGameCollectorForSolo(message, game, channelId) {
  // D'abord setup le collector normal
  setupGameCollector(message, game, channelId);
  
  // Si c'est le tour du bot au d√©marrage, le faire jouer
  setTimeout(async () => {
    const currentPlayer = game.getCurrentPlayer();
    if (currentPlayer && currentPlayer.id === 'UNO_BOT_AI') {
      await playBotTurn(game, message);
    }
  }, 1000);
}

function setupGameCollector(message, game, channelId) {
  const gameCollector = message.createMessageComponentCollector({ time: 0 });
  
  gameCollector.on("collect", async i => {
    const player = game.players.find(p => p.id === i.user.id);
    if (!player) return i.reply({ content: "‚ùå Pas dans la partie !", flags: (1 << 6) });
    
    if (i.customId === "uno_hand") {
      // Note: On ne peut pas supprimer les anciens messages √©ph√©m√®res
      // Mais ce n'est pas grave, ils ne sont visibles que par le joueur
      
      // Cr√©er l'image composite de la main
      const handImageBuffer = await createHandImage(player.hand);
      const handAttachment = new AttachmentBuilder(handImageBuffer, { name: 'hand.png' });
      
      // Afficher sanctions si pr√©sentes
      let description = "";
      const currentPlayer = game.getCurrentPlayer();
      if (player.id === currentPlayer.id && game.drawCount > 0) {
        description = `‚ö†Ô∏è **ATTENTION: Vous devez piocher ${game.drawCount} carte(s) ou jouer un +2 ou +4 pour cumuler !**\n\n`;
      }
      description += `Cliquez sur le numero de la carte pour la jouer.`;
      
      const handEmbed = new EmbedBuilder()
        .setColor(player.id === currentPlayer.id && game.drawCount > 0 ? "#FF0000" : "#0099FF")
        .setTitle("üÉè Votre Main UNO")
        .setDescription(description)
        .setImage('attachment://hand.png')
        .setFooter({ text: `Vous avez ${player.hand.length} carte(s)` });
      
      // Cr√©er les boutons pour jouer
      const rows = [];
      for (let idx = 0; idx < Math.min(player.hand.length, 25); idx += 5) {
        const row = new ActionRowBuilder();
        for (let j = idx; j < Math.min(idx + 5, player.hand.length); j++) {
          const card = player.hand[j];
          const emoji = game.getCardDisplay(card);
          row.addComponents(
            new ButtonBuilder()
              .setCustomId(`uno_play_${j}`)
              .setLabel(`${j + 1}`)
              .setEmoji(emoji)
              .setStyle(ButtonStyle.Primary)
          );
        }
        rows.push(row);
      }
      
      await i.deferReply({ flags: 1 << 6 });
      const handMsg = await i.editReply({ embeds: [handEmbed], files: [handAttachment], components: rows });
      
      // Collector pour les boutons de la main √©ph√©m√®re
      
      // Arr√™ter l'ancien collector s'il existe pour √©viter les empilements
      if (game.handCollectors.has(player.id)) {
        const oldCollector = game.handCollectors.get(player.id);
        oldCollector.stop();
      }
      
      const handCollector = handMsg.createMessageComponentCollector({ time: 0 });
      game.handCollectors.set(player.id, handCollector);
      
      handCollector.on("collect", async handInteraction => {
        if (handInteraction.user.id !== player.id) return;
        
        if (handInteraction.customId.startsWith("uno_play_")) {
          const cardIndex = parseInt(handInteraction.customId.split("_")[2]);
          const currentPlayer = game.getCurrentPlayer();
          
          if (currentPlayer.id !== handInteraction.user.id) {
            // Utiliser followUp pour les messages d'erreur √©ph√©m√®res
            return handInteraction.update({ content: "‚ùå Pas votre tour !", flags: (1 << 6) }).catch(() => {});
          }
          
          const card = player.hand[cardIndex];
          
          if (card && (card.type === "wild" || card.type === "wild_draw4")) {
            const colorRow = new ActionRowBuilder()
              .addComponents(
                new ButtonBuilder().setCustomId(`uno_color_${cardIndex}_red`).setLabel("üî¥ Rouge").setStyle(ButtonStyle.Danger),
                new ButtonBuilder().setCustomId(`uno_color_${cardIndex}_blue`).setLabel("üîµ Bleu").setStyle(ButtonStyle.Primary),
                new ButtonBuilder().setCustomId(`uno_color_${cardIndex}_green`).setLabel("üü¢ Vert").setStyle(ButtonStyle.Success),
                new ButtonBuilder().setCustomId(`uno_color_${cardIndex}_yellow`).setLabel("üü° Jaune").setStyle(ButtonStyle.Secondary)
              );
            // Utiliser followUp pour cr√©er un nouveau message avec les boutons de couleur
            // Acquitter l'interaction avec update, puis cr√©er le message de choix
            await handInteraction.update({ content: "Joker s√©lectionn√©, choisissez une couleur...", components: [] }).catch(() => {});
            const colorMsg = await handInteraction.followUp({ content: `Joker ${game.getCardDisplay(card)}. Choisissez une couleur:`, components: [colorRow], flags: (1 << 6) });
            
            const colorMsgFetched = colorMsg;
            // Collector pour les boutons de couleur
            const colorCollector = colorMsgFetched.createMessageComponentCollector({ time: 0 });
            
            colorCollector.on("collect", async colorInteraction => {
              if (colorInteraction.user.id !== player.id) return;
              
              if (colorInteraction.customId.startsWith("uno_color_")) {
                const parts = colorInteraction.customId.split("_");
                const cardIdx = parseInt(parts[2]);
                const color = parts[3];
                const result = game.playCard(colorInteraction.user.id, cardIdx, color);
                if (!result.success) return colorInteraction.reply({ content: `‚ùå ${result.error}`, flags: (1 << 6) });
                
                if (result.winner) {
                                    cleanupGameCollectors(game);
                  activeGames.delete(channelId);
                  gameCollector.stop();
                  handCollector.stop();
                  colorCollector.stop();
                  const winEmbed = new EmbedBuilder().setColor("#FFD700").setTitle("üéâ VICTOIRE !").setDescription(`${result.winner.username} a gagne !`);
                  await colorInteraction.update({ content: "‚úÖ Joker joue - VICTOIRE !", components: [] });
                  return message.edit({ embeds: [winEmbed], components: [], files: [] });
                }
                
                await colorInteraction.update({ content: "‚úÖ Joker joue !", components: [] });
                const { embed: gameEmbed, attachment } = game.createGameEmbed();
                const actionButtons = game.createActionButtons();
                await message.edit({ embeds: [gameEmbed], files: [attachment], components: [actionButtons] });
                // Si mode solo et c'est le tour du bot, le faire jouer
                if (game.isSoloMode) {
                  setTimeout(async () => {
                    const currentPlayer = game.getCurrentPlayer();
                    if (currentPlayer && currentPlayer.id === 'UNO_BOT_AI') {
                      await playBotTurn(game, message);
                    }
                  }, 1000);
                }
                
                // User peut recliquer sur "Ma main" pour voir sa main mise √† jour
              }
            });
            
            return;
          }
          
          const result = game.playCard(handInteraction.user.id, cardIndex);
          if (!result.success) {
            return handInteraction.update({ content: `‚ùå ${result.error}`, flags: (1 << 6) }).catch(() => {});
          }
          
          if (result.winner) {
            cleanupGameCollectors(game);
            activeGames.delete(channelId);
            gameCollector.stop();
            handCollector.stop();
            const winEmbed = new EmbedBuilder().setColor("#FFD700").setTitle("üéâ VICTOIRE !").setDescription(`${result.winner.username} a gagne !\n\nüèÜ Felicitations !`);
            await handInteraction.update({ content: "‚úÖ Victoire !", flags: (1 << 6) }).catch(() => {});
            return message.edit({ embeds: [winEmbed], components: [], files: [] });
          }
          
          // Confirmer l'action avec followUp
          await handInteraction.update({ content: "‚úÖ Carte jou√©e ! Recliquez sur 'Ma main' ci-dessus.", flags: (1 << 6) }).catch(() => {});
          
          // Mettre √† jour l'embed principal
          const { embed: gameEmbed, attachment } = game.createGameEmbed();
          const actionButtons = game.createActionButtons();
          await message.edit({ embeds: [gameEmbed], files: [attachment], components: [actionButtons] });
          // Si mode solo et c'est le tour du bot, le faire jouer
          if (game.isSoloMode) {
            setTimeout(async () => {
              const currentPlayer = game.getCurrentPlayer();
              if (currentPlayer && currentPlayer.id === 'UNO_BOT_AI') {
                await playBotTurn(game, message);
              }
            }, 1000);
          }
          
          // User peut recliquer sur "Ma main" pour voir sa main mise √† jour
        } else if (handInteraction.customId.startsWith("uno_color_")) {
          const parts = handInteraction.customId.split("_");
          const cardIndex = parseInt(parts[2]);
          const color = parts[3];
          const result = game.playCard(handInteraction.user.id, cardIndex, color);
          if (!result.success) {
            return colorInteraction.update({ content: `‚ùå ${result.error}`, flags: (1 << 6) }).catch(() => {});
          }
          
          if (result.winner) {
            cleanupGameCollectors(game);
            activeGames.delete(channelId);
            gameCollector.stop();
            handCollector.stop();
            const winEmbed = new EmbedBuilder().setColor("#FFD700").setTitle("üéâ VICTOIRE !").setDescription(`${result.winner.username} a gagne !`);
            await colorInteraction.update({ content: "‚úÖ Joker jou√© - VICTOIRE !", flags: (1 << 6) }).catch(() => {});
            return message.edit({ embeds: [winEmbed], components: [], files: [] });
          }
          
          await colorInteraction.update({ content: "‚úÖ Joker jou√© !", flags: (1 << 6) }).catch(() => {});
          const { embed: gameEmbed, attachment } = game.createGameEmbed();
          const actionButtons = game.createActionButtons();
          await message.edit({ embeds: [gameEmbed], files: [attachment], components: [actionButtons] });
          // Si mode solo et c'est le tour du bot, le faire jouer
          if (game.isSoloMode) {
            setTimeout(async () => {
              const currentPlayer = game.getCurrentPlayer();
              if (currentPlayer && currentPlayer.id === 'UNO_BOT_AI') {
                await playBotTurn(game, message);
              }
            }, 1000);
          }
        }
      });
      
    } else if (i.customId === "uno_draw") {
      const currentPlayer = game.getCurrentPlayer();
      if (currentPlayer.id !== i.user.id) return i.reply({ content: "‚ùå Pas votre tour !", flags: (1 << 6) });
      
      // Si drawCount > 0, piocher toutes les cartes de p√©nalit√©
      if (game.drawCount > 0) {
        const drawnCards = [];
        for (let idx = 0; idx < game.drawCount; idx++) {
          const card = game.drawCard(player);
          if (card) drawnCards.push(game.getCardDisplay(card));
        }
        const cardsList = drawnCards.join(' ');
        game.drawCount = 0;
        game.nextPlayer();
        await i.reply({ content: `‚úÖ Pioche de penalite: ${drawnCards.length} carte(s) piochees\n${cardsList}\n\nVous avez ${player.hand.length} cartes`, flags: (1 << 6) });
      } else {
        // Pioche normale (1 carte)
        const card = game.drawCard(player);
        game.nextPlayer();
        await i.reply({ content: `‚úÖ Pioche: ${game.getCardDisplay(card)}\n\nVous avez ${player.hand.length} cartes`, flags: (1 << 6) });
      }
      
      const { embed: gameEmbed, attachment } = game.createGameEmbed();
      const actionButtons = game.createActionButtons();
      await message.edit({ embeds: [gameEmbed], files: [attachment], components: [actionButtons] });
      // Si mode solo et c'est le tour du bot, le faire jouer
      if (game.isSoloMode) {
        setTimeout(async () => {
          const currentPlayer = game.getCurrentPlayer();
          if (currentPlayer && currentPlayer.id === 'UNO_BOT_AI') {
            await playBotTurn(game, message);
          }
        }, 1000);
      }
      
      } else if (i.customId === "uno_quit") {
      // En mode solo, arr√™ter compl√®tement le jeu
      if (game.isSoloMode) {
                cleanupGameCollectors(game);
        activeGames.delete(channelId);
        gameCollector.stop();
        await i.update({ content: "üõë Partie Solo annul√©e.", embeds: [], components: [] });
        return;
      }
      
      // Mode multi-joueurs: retirer le joueur normalement
      game.removePlayer(i.user.id);
      await i.reply({ content: "‚úÖ Vous avez quitte.", flags: (1 << 6) });
      if (game.players.length === 0) {
                cleanupGameCollectors(game);
        activeGames.delete(channelId);
        gameCollector.stop();
        return message.edit({ content: "üõë Partie annulee (plus de joueurs).", embeds: [], components: [] });
      }
      const { embed: gameEmbed, attachment } = game.createGameEmbed();
      const actionButtons = game.createActionButtons();
      await message.edit({ embeds: [gameEmbed], files: [attachment], components: [actionButtons] });
      // Si mode solo et c'est le tour du bot, le faire jouer
      if (game.isSoloMode) {
        setTimeout(async () => {
          const currentPlayer = game.getCurrentPlayer();
          if (currentPlayer && currentPlayer.id === 'UNO_BOT_AI') {
            await playBotTurn(game, message);
          }
        }, 1000);
      }
    }
  });
  
  gameCollector.on("end", () => {
    if (activeGames.has(channelId)) {
            cleanupGameCollectors(game);
      activeGames.delete(channelId);
    }
  });
}
