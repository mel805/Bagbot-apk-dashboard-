const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, AttachmentBuilder } = require('discord.js');
const path = require('path');
const { createCanvas, loadImage } = require('canvas');
const fs = require('fs');

// Mapping des emojis custom de cartes UNO (Application Emojis)
const EMOJI_MAP = {
  'uno_r0': '<:uno_r0:1433191075945779401>',
  'uno_r1': '<:uno_r1:1433191080567767062>',
  'uno_r2': '<:uno_r2:1433191085030641879>',
  'uno_r3': '<:uno_r3:1433191089107505315>',
  'uno_r4': '<:uno_r4:1433191093520040113>',
  'uno_r5': '<:uno_r5:1433191105091997696>',
  'uno_r6': '<:uno_r6:1433191109672177737>',
  'uno_r7': '<:uno_r7:1433191114504146945>',
  'uno_r8': '<:uno_r8:1433191118698319934>',
  'uno_r9': '<:uno_r9:1433191123299471443>',
  'uno_rskip': '<:uno_rskip:1433193235043319878>',
  'uno_rrev': '<:uno_rrev:1433194079927406663>',
  'uno_rp2': '<:uno_rp2:1433193252194095286>',
  'uno_b0': '<:uno_b0:1433191141376786577>',
  'uno_b1': '<:uno_b1:1433191146179264542>',
  'uno_b2': '<:uno_b2:1433191150436749439>',
  'uno_b3': '<:uno_b3:1433191154857279632>',
  'uno_b4': '<:uno_b4:1433191160167534774>',
  'uno_b5': '<:uno_b5:1433191165036859483>',
  'uno_b6': '<:uno_b6:1433191169285685362>',
  'uno_b7': '<:uno_b7:1433191174054613195>',
  'uno_b8': '<:uno_b8:1433191178676867124>',
  'uno_b9': '<:uno_b9:1433191183470825655>',
  'uno_bskip': '<:uno_bskip:1433193260691493085>',
  'uno_brev': '<:uno_brev:1433194088252838060>',
  'uno_bp2': '<:uno_bp2:1433193277284159651>',
  'uno_g0': '<:uno_g0:1433191202160640152>',
  'uno_g1': '<:uno_g1:1433191206363598939>',
  'uno_g2': '<:uno_g2:1433191211040116897>',
  'uno_g3': '<:uno_g3:1433191215565639830>',
  'uno_g4': '<:uno_g4:1433191220284493864>',
  'uno_g5': '<:uno_g5:1433191224751427595>',
  'uno_g6': '<:uno_g6:1433191229537124372>',
  'uno_g7': '<:uno_g7:1433191234104590518>',
  'uno_g8': '<:uno_g8:1433191238617534596>',
  'uno_g9': '<:uno_g9:1433191243822665749>',
  'uno_gskip': '<:uno_gskip:1433193285450465494>',
  'uno_grev': '<:uno_grev:1433194096327000167>',
  'uno_gp2': '<:uno_gp2:1433193303997808764>',
  'uno_y0': '<:uno_y0:1433191262227267696>',
  'uno_y1': '<:uno_y1:1433191266744664185>',
  'uno_y2': '<:uno_y2:1433191271219990598>',
  'uno_y3': '<:uno_y3:1433191275602907136>',
  'uno_y4': '<:uno_y4:1433191279696675040>',
  'uno_y5': '<:uno_y5:1433191284335575133>',
  'uno_y6': '<:uno_y6:1433191289620402267>',
  'uno_y7': '<:uno_y7:1433191294188126300>',
  'uno_y8': '<:uno_y8:1433191298747072644>',
  'uno_y9': '<:uno_y9:1433191303348359271>',
  'uno_yskip': '<:uno_yskip:1433193312336089108>',
  'uno_yrev': '<:uno_yrev:1433194105017733150>',
  'uno_yp2': '<:uno_yp2:1433193328903458937>',
  'uno_wild': '<:uno_wild:1433194845153005568>',
  'uno_wildp4': '<:uno_wildp4:1433194853495345263>',
};

// Fonction pour obtenir le chemin de l'image d'une carte
function getCardImagePath(card) {
  const color = card.chosenColor || card.color;
  const colorPrefix = { red: 'r', blue: 'b', green: 'g', yellow: 'y' };
  
  let filename = '';
  
  if (card.type === 'number') {
    filename = `uno_${colorPrefix[color]}${card.value}.png`;
  } else if (card.type === 'skip') {
    filename = `uno_${colorPrefix[color]}skip.png`;
  } else if (card.type === 'reverse') {
    filename = `uno_${colorPrefix[color]}rev.png`;
  } else if (card.type === 'draw2') {
    filename = `uno_${colorPrefix[color]}p2.png`;
  } else if (card.type === 'wild') {
    filename = 'uno_wild.png';
  } else if (card.type === 'wild_draw4') {
    filename = 'uno_wildp4.png';
  }
  
  return path.join(__dirname, '..', '..', 'uno-cards', filename);
}

// Fonction pour cr√©er une image composite de la main d'un joueur
async function createHandImage(cards) {
  const cardWidth = 400;
  const cardHeight = 600;
  const cardsPerRow = 4;
  const rows = Math.ceil(cards.length / cardsPerRow);
  const padding = 20;
  
  const canvasWidth = (cardWidth + padding) * Math.min(cardsPerRow, cards.length) + padding;
  const canvasHeight = (cardHeight + padding) * rows + padding;
  
  const canvas = createCanvas(canvasWidth, canvasHeight);
  const ctx = canvas.getContext('2d');
  
  // Fond transparent/sombre
  ctx.fillStyle = '#2C2F33';
  ctx.fillRect(0, 0, canvasWidth, canvasHeight);
  
  // Charger et dessiner chaque carte
  for (let i = 0; i < cards.length; i++) {
    const card = cards[i];
    const cardPath = getCardImagePath(card);
    
    if (fs.existsSync(cardPath)) {
      const image = await loadImage(cardPath);
      const row = Math.floor(i / cardsPerRow);
      const col = i % cardsPerRow;
      const x = padding + col * (cardWidth + padding);
      const y = padding + row * (cardHeight + padding);
      
      ctx.drawImage(image, x, y, cardWidth, cardHeight);
      
      // Num√©ro de la carte
      ctx.fillStyle = '#FFFFFF';
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 4;
      ctx.font = 'bold 60px Arial';
      ctx.strokeText(`${i + 1}`, x + 30, y + 70);
      ctx.fillText(`${i + 1}`, x + 30, y + 70);
    }
  }
  
  return canvas.toBuffer('image/png');
}

// Fonction pour obtenir l'emoji custom de carte UNO
function getCardVisual(card) {
  const color = card.chosenColor || card.color;
  const colorPrefix = { red: 'r', blue: 'b', green: 'g', yellow: 'y' };
  
  let emojiKey = '';
  
  if (card.type === 'number') {
    emojiKey = `uno_${colorPrefix[color]}${card.value}`;
  } else if (card.type === 'skip') {
    emojiKey = `uno_${colorPrefix[color]}skip`;
  } else if (card.type === 'reverse') {
    emojiKey = `uno_${colorPrefix[color]}rev`;
  } else if (card.type === 'draw2') {
    emojiKey = `uno_${colorPrefix[color]}p2`;
  } else if (card.type === 'wild') {
    emojiKey = 'uno_wild';
  } else if (card.type === 'wild_draw4') {
    emojiKey = 'uno_wildp4';
  }
  
  return EMOJI_MAP[emojiKey] || '‚ùì';
}

// Stockage des parties en cours
const activeGames = new Map();

class UnoGame {
  constructor(channelId, creatorId) {
    this.channelId = channelId;
    this.creatorId = creatorId;
    this.players = [];
    this.deck = [];
    this.discardPile = [];
    this.currentPlayerIndex = 0;
    this.direction = 1;
    this.started = false;
    this.drawCount = 0;
    this.messageId = null;
    this.collector = null;
  }

  addPlayer(userId, username) {
    if (this.started) return false;
    if (this.players.find(p => p.id === userId)) return false;
    if (this.players.length >= 10) return false;
    
    this.players.push({
      id: userId,
      username: username,
      hand: []
    });
    return true;
  }

  removePlayer(userId) {
    const index = this.players.findIndex(p => p.id === userId);
    if (index === -1) return false;
    
    this.players.splice(index, 1);
    
    if (this.currentPlayerIndex >= this.players.length) {
      this.currentPlayerIndex = 0;
    }
    
    return true;
  }

  createDeck() {
    this.deck = [];
    const colors = ['red', 'blue', 'green', 'yellow'];
    
    for (const color of colors) {
      this.deck.push({ type: 'number', color, value: 0 });
      for (let i = 1; i <= 9; i++) {
        this.deck.push({ type: 'number', color, value: i });
        this.deck.push({ type: 'number', color, value: i });
      }
    }
    
    for (const color of colors) {
      for (let i = 0; i < 2; i++) {
        this.deck.push({ type: 'skip', color });
        this.deck.push({ type: 'reverse', color });
        this.deck.push({ type: 'draw2', color });
      }
    }
    
    for (let i = 0; i < 4; i++) {
      this.deck.push({ type: 'wild', color: null });
      this.deck.push({ type: 'wild_draw4', color: null });
    }
    
    this.shuffle(this.deck);
  }

  shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
  }

  dealCards() {
    for (const player of this.players) {
      player.hand = [];
      for (let i = 0; i < 7; i++) {
        player.hand.push(this.deck.pop());
      }
    }
    
    let startCard;
    do {
      startCard = this.deck.pop();
    } while (startCard.type !== 'number');
    
    this.discardPile.push(startCard);
  }

  drawCard(player) {
    if (this.deck.length === 0) {
      const topCard = this.discardPile.pop();
      this.deck = [...this.discardPile];
      this.shuffle(this.deck);
      this.discardPile = [topCard];
    }
    
    if (this.deck.length > 0) {
      const card = this.deck.pop();
      player.hand.push(card);
      return card;
    }
    return null;
  }

  canPlayCard(card, topCard) {
    if (card.type === 'wild' || card.type === 'wild_draw4') return true;
    if (card.color === topCard.color) return true;
    
    const topColor = topCard.chosenColor || topCard.color;
    if (card.color === topColor) return true;
    
    if (card.type === 'number' && topCard.type === 'number' && card.value === topCard.value) return true;
    if (card.type === topCard.type && card.type !== 'number') return true;
    
    return false;
  }

  playCard(playerId, cardIndex, chosenColor = null) {
    const player = this.players[this.currentPlayerIndex];
    if (player.id !== playerId) return { success: false, error: "Ce n est pas votre tour !" };
    
    if (cardIndex < 0 || cardIndex >= player.hand.length) {
      return { success: false, error: "Carte invalide !" };
    }
    
    const card = player.hand[cardIndex];
    const topCard = this.discardPile[this.discardPile.length - 1];
    
    // Si drawCount > 0, on ne peut jouer que +2 ou +4 pour cumuler
    if (this.drawCount > 0) {
      if (card.type !== 'draw2' && card.type !== 'wild_draw4') {
        return { success: false, error: `Vous devez piocher ${this.drawCount} carte(s) ou jouer un +2/+4 !` };
      }
    }
    
    if (!this.canPlayCard(card, topCard)) {
      return { success: false, error: "Cette carte ne peut pas etre jouee !" };
    }
    
    if ((card.type === 'wild' || card.type === 'wild_draw4') && !chosenColor) {
      return { success: false, error: "Vous devez choisir une couleur !", requireColor: true };
    }
    
    player.hand.splice(cardIndex, 1);
    
    if (chosenColor) {
      card.chosenColor = chosenColor;
    }
    
    this.discardPile.push(card);
    
    if (player.hand.length === 0) {
      return { success: true, winner: player };
    }
    
    let skipNext = false;
    
    switch (card.type) {
      case 'skip':
        skipNext = true;
        break;
      
      case 'reverse':
        if (this.players.length === 2) {
          skipNext = true;
        } else {
          this.direction *= -1;
        }
        break;
      
      case 'draw2':
        this.drawCount += 2;
        skipNext = true;
        break;
      
      case 'wild_draw4':
        this.drawCount += 4;
        skipNext = true;
        break;
    }
    
    this.nextPlayer(skipNext);
    
    return { success: true };
  }

  nextPlayer(skip = false) {
    this.currentPlayerIndex += this.direction;
    
    if (this.currentPlayerIndex >= this.players.length) {
      this.currentPlayerIndex = 0;
    } else if (this.currentPlayerIndex < 0) {
      this.currentPlayerIndex = this.players.length - 1;
    }
    
    // Si skip et drawCount = 0, on passe encore au suivant
    if (skip && this.drawCount === 0) {
      this.nextPlayer(false);
    }
    // Si drawCount > 0, on NE passe PAS au suivant : le joueur doit piocher
  }

  getCardDisplay(card) {
    return getCardVisual(card);
  }

  getCurrentPlayer() {
    return this.players[this.currentPlayerIndex];
  }

  getTopCard() {
    return this.discardPile[this.discardPile.length - 1];
  }

  createGameEmbed() {
    const topCard = this.getTopCard();
    const currentPlayer = this.getCurrentPlayer();
    
    // Liste compacte des joueurs
    const playersList = this.players.map((p, i) => {
      const indicator = i === this.currentPlayerIndex ? "‚ñ∂" : "‚Ä¢";
      return `${indicator} ${p.username} (${p.hand.length})`;
    }).join("\n");
    
    const cardImagePath = getCardImagePath(topCard);
    const attachment = new AttachmentBuilder(cardImagePath, { name: 'current_card.png' });
    
    let description = `**Tour:** <@${currentPlayer.id}>`;
    if (this.drawCount > 0) {
      description += `\n‚ö†Ô∏è **${this.drawCount} carte(s) √† piocher**`;
    }
    
    // Sens + Pioche sur une ligne
    const sensIcon = this.direction === 1 ? "üîΩ" : "üîº";
    const infosLine = `${sensIcon} Sens ${this.direction === 1 ? "‚Üì" : "‚Üë"}  ‚Ä¢  üìö ${this.deck.length} cartes`;
    
    const embed = new EmbedBuilder()
      .setColor(this.drawCount > 0 ? "#FF0000" : "#FF5500")
      .setTitle("üéÆ UNO")
      .setDescription(description)
      .addFields(
        { name: "üë• Joueurs", value: playersList, inline: false },
        { name: "‚ÑπÔ∏è Infos", value: infosLine, inline: false }
      )
      .setImage('attachment://current_card.png')
      .setFooter({ text: this.drawCount > 0 ? "Piochez ou jouez +2/+4" : "Cliquez sur Ma main" });
    return { embed, attachment };
  }

  createActionButtons() {
    const row = new ActionRowBuilder()
      .addComponents(
        new ButtonBuilder()
          .setCustomId("uno_hand")
          .setLabel("üÉè Ma main")
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId("uno_draw")
          .setLabel("üé¥ Piocher")
          .setStyle(ButtonStyle.Secondary),
        new ButtonBuilder()
          .setCustomId("uno_quit")
          .setLabel("üö™ Quitter")
          .setStyle(ButtonStyle.Danger)
      );
    return row;
  }
}

module.exports = {
  name: "uno",
  data: new SlashCommandBuilder()
    .setName("uno")
    .setDescription("Jouer au UNO avec de vraies cartes !"),

  async execute(interaction) {
    const channelId = interaction.channelId;
    
    if (activeGames.has(channelId)) {
      return interaction.reply({ content: "‚ùå Une partie est deja en cours !", ephemeral: true });
    }
    
    const game = new UnoGame(channelId, interaction.user.id);
    game.addPlayer(interaction.user.id, interaction.user.username);
    activeGames.set(channelId, game);
    
    const lobbyEmbed = new EmbedBuilder()
      .setColor("#00FF00")
      .setTitle("üéÆ Nouvelle Partie UNO")
      .setDescription(`${interaction.user.username} a cree une partie !\n\n**Cliquez sur "Rejoindre"**\n*Minimum 2 joueurs*`)
      .addFields({ name: "üë• Joueurs (1/10)", value: `1Ô∏è‚É£ ${interaction.user.username}` })
      .setFooter({ text: "Le createur peut demarrer la partie" });
    
    const lobbyButtons = new ActionRowBuilder()
      .addComponents(
        new ButtonBuilder().setCustomId("uno_join").setLabel("‚úÖ Rejoindre").setStyle(ButtonStyle.Success),
        new ButtonBuilder().setCustomId("uno_start").setLabel("üöÄ Demarrer").setStyle(ButtonStyle.Primary),
        new ButtonBuilder().setCustomId("uno_cancel").setLabel("‚ùå Annuler").setStyle(ButtonStyle.Danger)
      );
    
    const message = await interaction.reply({ embeds: [lobbyEmbed], components: [lobbyButtons], fetchReply: true });
    game.messageId = message.id;
    
    const collector = message.createMessageComponentCollector({ time: 300000 });
    game.collector = collector;
    
    collector.on("collect", async i => {
      if (i.customId === "uno_join") {
        const success = game.addPlayer(i.user.id, i.user.username);
        if (!success) {
          if (game.started) return i.reply({ content: "‚ùå Partie commencee !", ephemeral: true });
          if (game.players.find(p => p.id === i.user.id)) return i.reply({ content: "‚ùå Deja dans la partie !", ephemeral: true });
          return i.reply({ content: "‚ùå Partie pleine !", ephemeral: true });
        }
        const numbers = ["1Ô∏è‚É£","2Ô∏è‚É£","3Ô∏è‚É£","4Ô∏è‚É£","5Ô∏è‚É£","6Ô∏è‚É£","7Ô∏è‚É£","8Ô∏è‚É£","9Ô∏è‚É£","üîü"];
        const playerList = game.players.map((p, idx) => `${numbers[idx]} ${p.username}`).join("\n");
        lobbyEmbed.spliceFields(0, 1, { name: `üë• Joueurs (${game.players.length}/10)`, value: playerList });
        await i.update({ embeds: [lobbyEmbed], components: [lobbyButtons] });
      } else if (i.customId === "uno_start") {
        if (game.creatorId !== i.user.id) return i.reply({ content: "‚ùå Seul le createur peut demarrer !", ephemeral: true });
        if (game.players.length < 2) return i.reply({ content: "‚ùå Minimum 2 joueurs !", ephemeral: true });
        game.started = true;
        game.createDeck();
        game.dealCards();
        const { embed: gameEmbed, attachment } = game.createGameEmbed();
        const actionButtons = game.createActionButtons();
        await i.update({ embeds: [gameEmbed], files: [attachment], components: [actionButtons] });
        setupGameCollector(message, game, channelId);
      } else if (i.customId === "uno_cancel") {
        if (game.creatorId !== i.user.id) return i.reply({ content: "‚ùå Seul le createur peut annuler !", ephemeral: true });
        activeGames.delete(channelId);
        collector.stop();
        await i.update({ content: "üõë Partie annulee.", embeds: [], components: [] });
      }
    });
    
    collector.on("end", () => {
      if (activeGames.has(channelId) && !activeGames.get(channelId).started) {
        activeGames.delete(channelId);
      }
    });
  }
};

function setupGameCollector(message, game, channelId) {
  const gameCollector = message.createMessageComponentCollector({ time: 1800000 });
  
  gameCollector.on("collect", async i => {
    const player = game.players.find(p => p.id === i.user.id);
    if (!player) return i.reply({ content: "‚ùå Pas dans la partie !", ephemeral: true });
    
    if (i.customId === "uno_hand") {
      // Defer l'interaction car la g√©n√©ration d'image prend du temps (3 secondes max Discord)
      await i.deferReply({ ephemeral: true });
      
      // Cr√©er l'image composite de la main
      const handImageBuffer = await createHandImage(player.hand);
      const handAttachment = new AttachmentBuilder(handImageBuffer, { name: 'hand.png' });
      
      // Afficher sanctions si pr√©sentes
      let description = "";
      const currentPlayer = game.getCurrentPlayer();
      if (player.id === currentPlayer.id && game.drawCount > 0) {
        description = `‚ö†Ô∏è **ATTENTION: Vous devez piocher ${game.drawCount} carte(s) ou jouer un +2 ou +4 pour cumuler !**\n\n`;
      }
      description += `Cliquez sur le numero de la carte pour la jouer.`;
      
      const handEmbed = new EmbedBuilder()
        .setColor(player.id === currentPlayer.id && game.drawCount > 0 ? "#FF0000" : "#0099FF")
        .setTitle("üÉè Votre Main UNO")
        .setDescription(description)
        .setImage('attachment://hand.png')
        .setFooter({ text: `Vous avez ${player.hand.length} carte(s)` });
      
      // Cr√©er les boutons pour jouer
      const rows = [];
      for (let idx = 0; idx < Math.min(player.hand.length, 10); idx += 5) {
        const row = new ActionRowBuilder();
        for (let j = idx; j < Math.min(idx + 5, player.hand.length); j++) {
          const card = player.hand[j];
          const emoji = game.getCardDisplay(card);
          row.addComponents(
            new ButtonBuilder()
              .setCustomId(`uno_play_${j}`)
              .setLabel(`${j + 1}`)
              .setEmoji(emoji)
              .setStyle(ButtonStyle.Primary)
          );
        }
        rows.push(row);
      }
      
      const handMsg = await i.editReply({ embeds: [handEmbed], files: [handAttachment], components: rows, fetchReply: true });
      
      // Collector pour les boutons de la main √©ph√©m√®re
      const handCollector = handMsg.createMessageComponentCollector({ time: 600000 });
      
      handCollector.on("collect", async handInteraction => {
        if (handInteraction.user.id !== player.id) return;
        
        console.log(`[UNO DEBUG] handCollector re√ßu: ${handInteraction.customId}, deferred=${handInteraction.deferred}, replied=${handInteraction.replied}`);
        
        // Defer seulement si pas d√©j√† defer (cas de redirect depuis newHandCollector)
        if (!handInteraction.deferred && !handInteraction.replied) {
          try {
            console.log('[UNO DEBUG] Tentative deferReply...');
            await handInteraction.deferReply({ ephemeral: true });
            console.log('[UNO DEBUG] deferReply SUCC√àS');
          } catch (err) {
            console.error(`[UNO ERROR] Impossible de defer: ${err.message}`);
            return;
          }
        } else {
          console.log(`[UNO DEBUG] Skip defer (d√©j√† defer ou replied)`);
        }
        
        if (handInteraction.customId.startsWith("uno_play_")) {
          const cardIndex = parseInt(handInteraction.customId.split("_")[2]);
          const currentPlayer = game.getCurrentPlayer();
          
          if (currentPlayer.id !== handInteraction.user.id) {
            return handInteraction.editReply({ content: "‚ùå Pas votre tour !" });
          }
          
          const card = player.hand[cardIndex];
          
          if (card && (card.type === "wild" || card.type === "wild_draw4")) {
            const colorRow = new ActionRowBuilder()
              .addComponents(
                new ButtonBuilder().setCustomId(`uno_color_${cardIndex}_red`).setLabel("üî¥ Rouge").setStyle(ButtonStyle.Danger),
                new ButtonBuilder().setCustomId(`uno_color_${cardIndex}_blue`).setLabel("üîµ Bleu").setStyle(ButtonStyle.Primary),
                new ButtonBuilder().setCustomId(`uno_color_${cardIndex}_green`).setLabel("üü¢ Vert").setStyle(ButtonStyle.Success),
                new ButtonBuilder().setCustomId(`uno_color_${cardIndex}_yellow`).setLabel("üü° Jaune").setStyle(ButtonStyle.Secondary)
              );
            const colorMsg = await handInteraction.editReply({ content: `Joker ${game.getCardDisplay(card)}. Choisissez une couleur:`, components: [colorRow], fetchReply: true });
            
            // Collector pour les boutons de couleur
            const colorCollector = colorMsg.createMessageComponentCollector({ time: 120000 });
            
            colorCollector.on("collect", async colorInteraction => {
              if (colorInteraction.user.id !== player.id) return;
              
              if (colorInteraction.customId.startsWith("uno_color_")) {
                const parts = colorInteraction.customId.split("_");
                const cardIdx = parseInt(parts[2]);
                const color = parts[3];
                const result = game.playCard(colorInteraction.user.id, cardIdx, color);
                if (!result.success) return colorInteraction.reply({ content: `‚ùå ${result.error}`, ephemeral: true });
                
                if (result.winner) {
                  activeGames.delete(channelId);
                  gameCollector.stop();
                  handCollector.stop();
                  colorCollector.stop();
                  const winEmbed = new EmbedBuilder().setColor("#FFD700").setTitle("üéâ VICTOIRE !").setDescription(`${result.winner.username} a gagne !`);
                  await colorInteraction.update({ content: "‚úÖ Joker joue - VICTOIRE !", components: [] });
                  return message.edit({ embeds: [winEmbed], components: [], files: [] });
                }
                
                await colorInteraction.update({ content: "‚úÖ Joker joue !", components: [] });
                const { embed: gameEmbed, attachment } = game.createGameEmbed();
                const actionButtons = game.createActionButtons();
                await message.edit({ embeds: [gameEmbed], files: [attachment], components: [actionButtons] });
                
                // Cr√©er un nouveau message de main
                try {
                  // NE PAS arr√™ter handCollector
                  colorCollector.stop();
                  // Note: On ne supprime pas les messages √©ph√©m√®res
                  
                  const newHandAttachment = new AttachmentBuilder(newHandImageBuffer, { name: 'hand.png' });
                  
                  let newDescription = "";
                  const currentPlayerNow = game.getCurrentPlayer();
                  if (player.id === currentPlayerNow.id && game.drawCount > 0) {
                    newDescription = `‚ö†Ô∏è **ATTENTION: Vous devez piocher ${game.drawCount} carte(s) ou jouer un +2 ou +4 pour cumuler !**\n\n`;
                  }
                  newDescription += `Cliquez sur le numero de la carte pour la jouer.`;
                  
                  const newHandEmbed = new EmbedBuilder()
                    .setColor(player.id === currentPlayerNow.id && game.drawCount > 0 ? "#FF0000" : "#0099FF")
                    .setTitle("üÉè Votre Main UNO - Mise √† jour")
                    .setDescription(newDescription)
                    .setImage('attachment://hand.png')
                    .setFooter({ text: `Vous avez ${player.hand.length} carte(s)` });
                  
                  const newRows = [];
                  for (let idx = 0; idx < Math.min(player.hand.length, 10); idx += 5) {
                    const row = new ActionRowBuilder();
                    for (let j = idx; j < Math.min(idx + 5, player.hand.length); j++) {
                      const cardBtn = player.hand[j];
                      const emojiBtn = game.getCardDisplay(cardBtn);
                      row.addComponents(
                        new ButtonBuilder()
                          .setCustomId(`uno_play_${j}`)
                          .setLabel(`${j + 1}`)
                          .setEmoji(emojiBtn)
                          .setStyle(ButtonStyle.Primary)
                      );
                    }
                    newRows.push(row);
                  }
                  
                  const newHandMsg = await colorInteraction.followUp({ embeds: [newHandEmbed], files: [newHandAttachment], components: newRows, ephemeral: true });
                  
                  const newHandCollector = newHandMsg.createMessageComponentCollector({ time: 600000 });
                  newHandCollector.on("collect", async hi => {
                    if (hi.user.id !== player.id) return;
                    if (hi.customId.startsWith("uno_play_")) {
                      // Defer avant de rediriger
                      try {
                        await hi.deferReply({ ephemeral: true });
                      } catch (err) {
                        console.log('[UNO] Defer newHandCollector(joker) √©chou√©:', err.message);
                        return;
                      }
                      handCollector.emit('collect', hi);
                    }
                  });
                } catch (err) {
                  console.error('Erreur mise √† jour main:', err.message);
                }
              }
            });
            
            return;
          }
          
          const result = game.playCard(handInteraction.user.id, cardIndex);
          if (!result.success) return handInteraction.editReply({ content: `‚ùå ${result.error}` });
          
          if (result.winner) {
            activeGames.delete(channelId);
            gameCollector.stop();
            handCollector.stop();
            const winEmbed = new EmbedBuilder().setColor("#FFD700").setTitle("üéâ VICTOIRE !").setDescription(`${result.winner.username} a gagne !\n\nüèÜ Felicitations !`);
            await handInteraction.editReply({ content: "‚úÖ Victoire !" });
            return message.edit({ embeds: [winEmbed], components: [], files: [] });
          }
          
          // Confirmer l'action √† Discord (OBLIGATOIRE apr√®s defer)
          console.log('[UNO DEBUG] Avant editReply...');
          try {
            await handInteraction.editReply({ content: "‚úÖ Carte jou√©e !" });
            console.log('[UNO DEBUG] editReply SUCC√àS');
          } catch (err) {
            console.error(`[UNO ERROR] editReply √©chou√©: ${err.message}`);
            // Essayer avec update si editReply √©choue
            try {
              await handInteraction.update({ content: "‚úÖ Carte jou√©e !", components: [] });
              console.log('[UNO DEBUG] update SUCC√àS (fallback)');
            } catch (err2) {
              console.error(`[UNO ERROR] update aussi √©chou√©: ${err2.message}`);
            }
          }
          
          // Mettre √† jour l'embed principal
          const { embed: gameEmbed, attachment } = game.createGameEmbed();
          const actionButtons = game.createActionButtons();
          await message.edit({ embeds: [gameEmbed], files: [attachment], components: [actionButtons] });
          
          // Cr√©er un nouveau message de main (Discord ne permet pas d'√©diter les fichiers √©ph√©m√®res)
          try {
            // NE PAS arr√™ter handCollector - il doit rester actif
            // Note: On ne supprime pas les messages √©ph√©m√®res (Discord ne le permet pas)
            
            // Cr√©er le nouveau message de main
            const newHandImageBuffer = await createHandImage(player.hand);
            const newHandAttachment = new AttachmentBuilder(newHandImageBuffer, { name: 'hand.png' });
            
            let newDescription = "";
            const currentPlayerNow = game.getCurrentPlayer();
            if (player.id === currentPlayerNow.id && game.drawCount > 0) {
              newDescription = `‚ö†Ô∏è **ATTENTION: Vous devez piocher ${game.drawCount} carte(s) ou jouer un +2 ou +4 pour cumuler !**\n\n`;
            }
            newDescription += `Cliquez sur le numero de la carte pour la jouer.`;
            
            const newHandEmbed = new EmbedBuilder()
              .setColor(player.id === currentPlayerNow.id && game.drawCount > 0 ? "#FF0000" : "#0099FF")
              .setTitle("üÉè Votre Main UNO - Mise √† jour")
              .setDescription(newDescription)
              .setImage('attachment://hand.png')
              .setFooter({ text: `Vous avez ${player.hand.length} carte(s)` });
            
            const newRows = [];
            for (let idx = 0; idx < Math.min(player.hand.length, 10); idx += 5) {
              const row = new ActionRowBuilder();
              for (let j = idx; j < Math.min(idx + 5, player.hand.length); j++) {
                const cardBtn = player.hand[j];
                const emojiBtn = game.getCardDisplay(cardBtn);
                row.addComponents(
                  new ButtonBuilder()
                    .setCustomId(`uno_play_${j}`)
                    .setLabel(`${j + 1}`)
                    .setEmoji(emojiBtn)
                    .setStyle(ButtonStyle.Primary)
                );
              }
              newRows.push(row);
            }
            
            // Envoyer le nouveau message et relancer le collector
            const newHandMsg = await handInteraction.followUp({ embeds: [newHandEmbed], files: [newHandAttachment], components: newRows, ephemeral: true });
            
            // Nouveau collector pour le nouveau message - il doit g√©rer ses propres interactions
            const newHandCollector = newHandMsg.createMessageComponentCollector({ time: 600000 });
            newHandCollector.on("collect", async hi => {
              if (hi.user.id !== player.id) return;
              
              // Traiter directement l'interaction au lieu de rediriger
              if (hi.customId.startsWith("uno_play_")) {
                // √âmettre vers le collector principal qui est toujours actif
                handCollector.emit('collect', hi);
              }
            });
          } catch (err) {
            console.error('Erreur mise √† jour main:', err.message);
          }
        } else if (handInteraction.customId.startsWith("uno_color_")) {
          const parts = handInteraction.customId.split("_");
          const cardIndex = parseInt(parts[2]);
          const color = parts[3];
          const result = game.playCard(handInteraction.user.id, cardIndex, color);
          if (!result.success) return handInteraction.editReply({ content: `‚ùå ${result.error}` });
          
          if (result.winner) {
            activeGames.delete(channelId);
            gameCollector.stop();
            handCollector.stop();
            const winEmbed = new EmbedBuilder().setColor("#FFD700").setTitle("üéâ VICTOIRE !").setDescription(`${result.winner.username} a gagne !`);
            await handInteraction.editReply({ content: "‚úÖ Joker jou√© !" });
            return message.edit({ embeds: [winEmbed], components: [], files: [] });
          }
          
          await handInteraction.editReply({ content: "‚úÖ Joker jou√© !" });
          const { embed: gameEmbed, attachment } = game.createGameEmbed();
          const actionButtons = game.createActionButtons();
          await message.edit({ embeds: [gameEmbed], files: [attachment], components: [actionButtons] });
        }
      });
      
    } else if (i.customId === "uno_draw") {
      const currentPlayer = game.getCurrentPlayer();
      if (currentPlayer.id !== i.user.id) return i.reply({ content: "‚ùå Pas votre tour !", ephemeral: true });
      
      // Si drawCount > 0, piocher toutes les cartes de p√©nalit√©
      if (game.drawCount > 0) {
        const drawnCards = [];
        for (let idx = 0; idx < game.drawCount; idx++) {
          const card = game.drawCard(player);
          if (card) drawnCards.push(game.getCardDisplay(card));
        }
        const cardsList = drawnCards.join(' ');
        game.drawCount = 0;
        game.nextPlayer();
        await i.reply({ content: `‚úÖ Pioche de penalite: ${drawnCards.length} carte(s) piochees\n${cardsList}\n\nVous avez ${player.hand.length} cartes`, ephemeral: true });
      } else {
        // Pioche normale (1 carte)
        const card = game.drawCard(player);
        game.nextPlayer();
        await i.reply({ content: `‚úÖ Pioche: ${game.getCardDisplay(card)}\n\nVous avez ${player.hand.length} cartes`, ephemeral: true });
      }
      
      const { embed: gameEmbed, attachment } = game.createGameEmbed();
      const actionButtons = game.createActionButtons();
      await message.edit({ embeds: [gameEmbed], files: [attachment], components: [actionButtons] });
      
      // Mettre √† jour automatiquement la main du joueur si elle est ouverte
      if (game.players.find(p => p.id === player.id)) {
        // Recr√©er le message de main avec les cartes mises √† jour
        try {
          const handImageBuffer = await createHandImage(player.hand);
          const handAttachment = new AttachmentBuilder(handImageBuffer, { name: 'hand.png' });
          
          let description = "";
          const currentPlayerNow = game.getCurrentPlayer();
          if (player.id === currentPlayerNow.id && game.drawCount > 0) {
            description = `‚ö†Ô∏è **ATTENTION: Vous devez piocher ${game.drawCount} carte(s) ou jouer un +2 ou +4 pour cumuler !**\n\n`;
          }
          description += `Cliquez sur le numero de la carte pour la jouer.`;
          
          const handEmbed = new EmbedBuilder()
            .setColor(player.id === currentPlayerNow.id && game.drawCount > 0 ? "#FF0000" : "#0099FF")
            .setTitle("üÉè Votre Main UNO - Mise √† jour")
            .setDescription(description)
            .setImage('attachment://hand.png')
            .setFooter({ text: `Vous avez ${player.hand.length} carte(s)` });
          
          const rows = [];
          for (let idx = 0; idx < Math.min(player.hand.length, 10); idx += 5) {
            const row = new ActionRowBuilder();
            for (let j = idx; j < Math.min(idx + 5, player.hand.length); j++) {
              const cardBtn = player.hand[j];
              const emojiBtn = game.getCardDisplay(cardBtn);
              row.addComponents(
                new ButtonBuilder()
                  .setCustomId(`uno_play_${j}`)
                  .setLabel(`${j + 1}`)
                  .setEmoji(emojiBtn)
                  .setStyle(ButtonStyle.Primary)
              );
            }
            rows.push(row);
          }
          
          // Cr√©er le nouveau message de main (les anciens messages √©ph√©m√®res restent mais ne sont visibles que par le joueur)
          const newHandMsg = await i.followUp({ embeds: [handEmbed], files: [handAttachment], components: rows, ephemeral: true });
          
          // Cr√©er un collector pour ce nouveau message (sinon les boutons ne fonctionneront pas)
          const newHandCollector = newHandMsg.createMessageComponentCollector({ time: 600000 });
          newHandCollector.on("collect", async handInteraction => {
            if (handInteraction.user.id !== player.id) return;
            
            // Defer imm√©diatement pour √©viter timeout
            try {
              await handInteraction.deferReply({ ephemeral: true });
            } catch (err) {
              console.log('[UNO] Interaction d√©j√† defer ou expir√©e (piocher):', err.message);
              return;
            }
            
            if (handInteraction.customId.startsWith("uno_play_")) {
              const cardIdx = parseInt(handInteraction.customId.split("_")[2]);
              const currentPlayer = game.getCurrentPlayer();
              
              if (currentPlayer.id !== handInteraction.user.id) {
                return handInteraction.editReply({ content: "‚ùå Pas votre tour !" });
              }
              
              const card = player.hand[cardIdx];
              
              if (card && (card.type === "wild" || card.type === "wild_draw4")) {
                const colorRow = new ActionRowBuilder()
                  .addComponents(
                    new ButtonBuilder().setCustomId(`uno_color_${cardIdx}_red`).setLabel("üî¥ Rouge").setStyle(ButtonStyle.Danger),
                    new ButtonBuilder().setCustomId(`uno_color_${cardIdx}_blue`).setLabel("üîµ Bleu").setStyle(ButtonStyle.Primary),
                    new ButtonBuilder().setCustomId(`uno_color_${cardIdx}_green`).setLabel("üü¢ Vert").setStyle(ButtonStyle.Success),
                    new ButtonBuilder().setCustomId(`uno_color_${cardIdx}_yellow`).setLabel("üü° Jaune").setStyle(ButtonStyle.Secondary)
                  );
                const colorMsg = await handInteraction.editReply({ content: `Joker ${game.getCardDisplay(card)}. Choisissez une couleur:`, components: [colorRow], fetchReply: true });
                
                const colorCollector = colorMsg.createMessageComponentCollector({ time: 120000 });
                colorCollector.on("collect", async colorInteraction => {
                  if (colorInteraction.user.id !== player.id) return;
                  
                  if (colorInteraction.customId.startsWith("uno_color_")) {
                    const parts = colorInteraction.customId.split("_");
                    const cIdx = parseInt(parts[2]);
                    const color = parts[3];
                    const result = game.playCard(colorInteraction.user.id, cIdx, color);
                    if (!result.success) return colorInteraction.reply({ content: `‚ùå ${result.error}`, ephemeral: true });
                    
                    if (result.winner) {
                      activeGames.delete(channelId);
                      gameCollector.stop();
                      newHandCollector.stop();
                      colorCollector.stop();
                      const winEmbed = new EmbedBuilder().setColor("#FFD700").setTitle("üéâ VICTOIRE !").setDescription(`${result.winner.username} a gagne !`);
                      await colorInteraction.update({ content: "‚úÖ Joker joue - VICTOIRE !", components: [] });
                      return message.edit({ embeds: [winEmbed], components: [], files: [] });
                    }
                    
                    await colorInteraction.update({ content: "‚úÖ Joker joue !", components: [] });
                    const { embed: gEmbed, attachment: gAttach } = game.createGameEmbed();
                    const actButtons = game.createActionButtons();
                    await message.edit({ embeds: [gEmbed], files: [gAttach], components: [actButtons] });
                  }
                });
                
                return;
              }
              
              const result = game.playCard(handInteraction.user.id, cardIdx);
              if (!result.success) return handInteraction.editReply({ content: `‚ùå ${result.error}` });
              
              if (result.winner) {
                activeGames.delete(channelId);
                gameCollector.stop();
                newHandCollector.stop();
                const winEmbed = new EmbedBuilder().setColor("#FFD700").setTitle("üéâ VICTOIRE !").setDescription(`${result.winner.username} a gagne !`);
                await handInteraction.editReply({ content: "‚úÖ Victoire !" });
                return message.edit({ embeds: [winEmbed], components: [], files: [] });
              }
              
              // Pas de message de confirmation, juste mettre √† jour l'embed principal
              const { embed: gEmbed, attachment: gAttach } = game.createGameEmbed();
              const actButtons = game.createActionButtons();
              await message.edit({ embeds: [gEmbed], files: [gAttach], components: [actButtons] });
            }
          });
        } catch (err) {
          console.error('Erreur mise √† jour main apr√®s pioche:', err.message);
        }
      }
      
    } else if (i.customId.startsWith("uno_color_")) {
      const parts = i.customId.split("_");
      const cardIndex = parseInt(parts[2]);
      const color = parts[3];
      const result = game.playCard(i.user.id, cardIndex, color);
      if (!result.success) return i.reply({ content: `‚ùå ${result.error}`, ephemeral: true });
      
      if (result.winner) {
        activeGames.delete(channelId);
        gameCollector.stop();
        const winEmbed = new EmbedBuilder().setColor("#FFD700").setTitle("üéâ VICTOIRE !").setDescription(`${result.winner.username} a gagne !`);
        return i.update({ embeds: [winEmbed], components: [] });
      }
      
      await i.update({ content: "‚úÖ Joker joue !", components: [] });
      const { embed: gameEmbed, attachment } = game.createGameEmbed();
      const actionButtons = game.createActionButtons();
      await message.edit({ embeds: [gameEmbed], files: [attachment], components: [actionButtons] });
      
    } else if (i.customId === "uno_quit") {
      game.removePlayer(i.user.id);
      await i.reply({ content: "‚úÖ Vous avez quitte.", ephemeral: true });
      if (game.players.length === 0) {
        activeGames.delete(channelId);
        gameCollector.stop();
        return message.edit({ content: "üõë Partie annulee (plus de joueurs).", embeds: [], components: [] });
      }
      const { embed: gameEmbed, attachment } = game.createGameEmbed();
      const actionButtons = game.createActionButtons();
      await message.edit({ embeds: [gameEmbed], files: [attachment], components: [actionButtons] });
    }
  });
  
  gameCollector.on("end", () => {
    if (activeGames.has(channelId)) {
      activeGames.delete(channelId);
    }
  });
}
