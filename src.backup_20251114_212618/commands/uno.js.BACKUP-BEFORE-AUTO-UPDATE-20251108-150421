const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, AttachmentBuilder } = require('discord.js');
const path = require('path');
const { createCanvas, loadImage } = require('canvas');
const fs = require('fs');

// Mapping des emojis custom de cartes UNO (Application Emojis)
const EMOJI_MAP = {
  'uno_r0': '<:uno_r0:1433191075945779401>',
  'uno_r1': '<:uno_r1:1433191080567767062>',
  'uno_r2': '<:uno_r2:1433191085030641879>',
  'uno_r3': '<:uno_r3:1433191089107505315>',
  'uno_r4': '<:uno_r4:1433191093520040113>',
  'uno_r5': '<:uno_r5:1433191105091997696>',
  'uno_r6': '<:uno_r6:1433191109672177737>',
  'uno_r7': '<:uno_r7:1433191114504146945>',
  'uno_r8': '<:uno_r8:1433191118698319934>',
  'uno_r9': '<:uno_r9:1433191123299471443>',
  'uno_rskip': '<:uno_rskip:1433193235043319878>',
  'uno_rrev': '<:uno_rrev:1433194079927406663>',
  'uno_rp2': '<:uno_rp2:1433193252194095286>',
  'uno_b0': '<:uno_b0:1433191141376786577>',
  'uno_b1': '<:uno_b1:1433191146179264542>',
  'uno_b2': '<:uno_b2:1433191150436749439>',
  'uno_b3': '<:uno_b3:1433191154857279632>',
  'uno_b4': '<:uno_b4:1433191160167534774>',
  'uno_b5': '<:uno_b5:1433191165036859483>',
  'uno_b6': '<:uno_b6:1433191169285685362>',
  'uno_b7': '<:uno_b7:1433191174054613195>',
  'uno_b8': '<:uno_b8:1433191178676867124>',
  'uno_b9': '<:uno_b9:1433191183470825655>',
  'uno_bskip': '<:uno_bskip:1433193260691493085>',
  'uno_brev': '<:uno_brev:1433194088252838060>',
  'uno_bp2': '<:uno_bp2:1433193277284159651>',
  'uno_g0': '<:uno_g0:1433191202160640152>',
  'uno_g1': '<:uno_g1:1433191206363598939>',
  'uno_g2': '<:uno_g2:1433191211040116897>',
  'uno_g3': '<:uno_g3:1433191215565639830>',
  'uno_g4': '<:uno_g4:1433191220284493864>',
  'uno_g5': '<:uno_g5:1433191224751427595>',
  'uno_g6': '<:uno_g6:1433191229537124372>',
  'uno_g7': '<:uno_g7:1433191234104590518>',
  'uno_g8': '<:uno_g8:1433191238617534596>',
  'uno_g9': '<:uno_g9:1433191243822665749>',
  'uno_gskip': '<:uno_gskip:1433193285450465494>',
  'uno_grev': '<:uno_grev:1433194096327000167>',
  'uno_gp2': '<:uno_gp2:1433193303997808764>',
  'uno_y0': '<:uno_y0:1433191262227267696>',
  'uno_y1': '<:uno_y1:1433191266744664185>',
  'uno_y2': '<:uno_y2:1433191271219990598>',
  'uno_y3': '<:uno_y3:1433191275602907136>',
  'uno_y4': '<:uno_y4:1433191279696675040>',
  'uno_y5': '<:uno_y5:1433191284335575133>',
  'uno_y6': '<:uno_y6:1433191289620402267>',
  'uno_y7': '<:uno_y7:1433191294188126300>',
  'uno_y8': '<:uno_y8:1433191298747072644>',
  'uno_y9': '<:uno_y9:1433191303348359271>',
  'uno_yskip': '<:uno_yskip:1433193312336089108>',
  'uno_yrev': '<:uno_yrev:1433194105017733150>',
  'uno_yp2': '<:uno_yp2:1433193328903458937>',
  'uno_wild': '<:uno_wild:1433194845153005568>',
  'uno_wildp4': '<:uno_wildp4:1433194853495345263>',
};

// Fonction pour obtenir le chemin de l'image d'une carte
function getCardImagePath(card) {
  const color = card.chosenColor || card.color;
  const colorPrefix = { red: 'r', blue: 'b', green: 'g', yellow: 'y' };
  
  let filename = '';
  
  if (card.type === 'number') {
    filename = `uno_${colorPrefix[color]}${card.value}.png`;
  } else if (card.type === 'skip') {
    filename = `uno_${colorPrefix[color]}skip.png`;
  } else if (card.type === 'reverse') {
    filename = `uno_${colorPrefix[color]}rev.png`;
  } else if (card.type === 'draw2') {
    filename = `uno_${colorPrefix[color]}p2.png`;
  } else if (card.type === 'wild') {
    filename = 'uno_wild.png';
  } else if (card.type === 'wild_draw4') {
    filename = 'uno_wildp4.png';
  }
  
  return path.join(__dirname, '..', '..', 'uno-cards', filename);
}

// Fonction pour cr√©er une image composite de la main d'un joueur en √©ventail
async function createHandImage(cards) {
  // Taille des cartes (r√©duite pour l'√©ventail)
  const cardWidth = 200;
  const cardHeight = 300;
  
  // Param√®tres de l'√©ventail
  const numCards = cards.length;
  const maxAngle = Math.min(90, numCards * 12); // Maximum 90¬∞ d'ouverture
  const angleStep = numCards > 1 ? maxAngle / (numCards - 1) : 0;
  const startAngle = -maxAngle / 2;
  
  // Rayon de l'arc (distance du centre aux cartes)
  const radius = 400;
  
  // Dimensions du canvas (assez grand pour contenir l'√©ventail)
  const canvasWidth = 1400;
  const canvasHeight = 700;
  
  const canvas = createCanvas(canvasWidth, canvasHeight);
  const ctx = canvas.getContext('2d');
  
  // Fond transparent/sombre
  ctx.fillStyle = '#2C2F33';
  ctx.fillRect(0, 0, canvasWidth, canvasHeight);
  
  // Point central de l'√©ventail (en bas au centre)
  const centerX = canvasWidth / 2;
  const centerY = canvasHeight + 100;
  
  // Charger et dessiner chaque carte en √©ventail
  for (let i = 0; i < cards.length; i++) {
    const card = cards[i];
    const cardPath = getCardImagePath(card);
    
    if (fs.existsSync(cardPath)) {
      const image = await loadImage(cardPath);
      
      // Calculer l'angle de cette carte
      const angle = (startAngle + i * angleStep) * Math.PI / 180;
      
      // Calculer la position de la carte
      const x = centerX + radius * Math.sin(angle);
      const y = centerY - radius * Math.cos(angle);
      
      // Sauvegarder l'√©tat du contexte
      ctx.save();
      
      // Se d√©placer au centre de la carte
      ctx.translate(x, y);
      
      // Rotation de la carte selon l'angle de l'√©ventail
      ctx.rotate(angle);
      
      // Dessiner la carte centr√©e
      ctx.drawImage(image, -cardWidth / 2, -cardHeight / 2, cardWidth, cardHeight);
      
      // Dessiner le num√©ro de la carte
      ctx.fillStyle = '#FFFFFF';
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 3;
      ctx.font = 'bold 40px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      // Positionner le num√©ro en haut de la carte
      ctx.strokeText(`${i + 1}`, 0, -cardHeight / 2 + 35);
      ctx.fillText(`${i + 1}`, 0, -cardHeight / 2 + 35);
      
      // Restaurer l'√©tat du contexte
      ctx.restore();
    }
  }
  
  return canvas.toBuffer('image/png');
}

// Fonction pour obtenir l'emoji custom de carte UNO
function getCardVisual(card) {
  const color = card.chosenColor || card.color;
  const colorPrefix = { red: 'r', blue: 'b', green: 'g', yellow: 'y' };
  
  let emojiKey = '';
  
  if (card.type === 'number') {
    emojiKey = `uno_${colorPrefix[color]}${card.value}`;
  } else if (card.type === 'skip') {
    emojiKey = `uno_${colorPrefix[color]}skip`;
  } else if (card.type === 'reverse') {
    emojiKey = `uno_${colorPrefix[color]}rev`;
  } else if (card.type === 'draw2') {
    emojiKey = `uno_${colorPrefix[color]}p2`;
  } else if (card.type === 'wild') {
    emojiKey = 'uno_wild';
  } else if (card.type === 'wild_draw4') {
    emojiKey = 'uno_wildp4';
  }
  
  return EMOJI_MAP[emojiKey] || '‚ùì';
}

// Stockage des parties en cours
const activeGames = new Map();


// ============================================================
// ü§ñ ROBOT IA pour mode solo
// ============================================================
async function playBotTurn(game, message) {
  // Attendre 2 secondes pour simuler la r√©flexion
  await new Promise(resolve => setTimeout(resolve, 2000));
  
  const botPlayer = game.players.find(p => p.id === 'UNO_BOT_AI');
  if (!botPlayer) return;
  
  const currentPlayer = game.getCurrentPlayer();
  if (currentPlayer.id !== 'UNO_BOT_AI') return;
  
  // Strat√©gie du bot: jouer la premi√®re carte valide
  let cardPlayed = false;
  
  for (let i = 0; i < botPlayer.hand.length; i++) {
    const card = botPlayer.hand[i];
    const topCard = game.discardPile[game.discardPile.length - 1];
    
    // V√©rifier si la carte peut √™tre jou√©e
    if (card.type === 'wild' || card.type === 'wild_draw4') {
      // Joker: choisir la couleur la plus pr√©sente dans la main
      const colors = { red: 0, blue: 0, green: 0, yellow: 0 };
      botPlayer.hand.forEach(c => {
        if (c.color && c.color !== 'wild') colors[c.color]++;
      });
      const bestColor = Object.keys(colors).reduce((a, b) => colors[a] > colors[b] ? a : b);
      
      const result = game.playCard('UNO_BOT_AI', i, bestColor);
      if (result.success) {
        cardPlayed = true;
        console.log(`[UNO BOT] Joue ${game.getCardDisplay(card)} (joker ‚Üí ${bestColor})`);
        
        if (result.winner) {
          activeGames.delete(game.channelId);
          const winEmbed = new EmbedBuilder().setColor('#FFD700').setTitle('üéâ VICTOIRE !').setDescription('ü§ñ Le Robot a gagn√© !\n\nR√©essayez !');
          return message.edit({ embeds: [winEmbed], components: [], files: [] });
        }
        break;
      }
    } else if (card.color === topCard.color || 
               card.value === topCard.value || 
               card.type === topCard.type) {
      const result = game.playCard('UNO_BOT_AI', i);
      if (result.success) {
        cardPlayed = true;
        console.log(`[UNO BOT] Joue ${game.getCardDisplay(card)}`);
        
        if (result.winner) {
          activeGames.delete(game.channelId);
          const winEmbed = new EmbedBuilder().setColor('#FFD700').setTitle('üéâ VICTOIRE !').setDescription('ü§ñ Le Robot a gagn√© !\n\nR√©essayez !');
          return message.edit({ embeds: [winEmbed], components: [], files: [] });
        }
        break;
      }
    }
  }
  
  // Si aucune carte n'a pu √™tre jou√©e, piocher
  if (!cardPlayed) {
    // Si drawCount > 0 (p√©nalit√© +2/+4), piocher toutes les cartes
    if (game.drawCount > 0) {
      const drawnCards = [];
      for (let idx = 0; idx < game.drawCount; idx++) {
        const card = game.drawCard(botPlayer);
        if (card) drawnCards.push(game.getCardDisplay(card));
      }
      console.log(`[UNO BOT] Pioche p√©nalit√©: ${game.drawCount} carte(s) - ${drawnCards.join(' ')}`);
      game.drawCount = 0; // R√©initialiser le compteur
    } else {
      // Pioche normale (1 carte)
      const card = game.drawCard(botPlayer);
      console.log(`[UNO BOT] Pioche: ${game.getCardDisplay(card)}`);
    }
    game.nextPlayer();
  }
  
  // Mettre √† jour l'affichage
  const { embed: gameEmbed, attachment } = game.createGameEmbed();
  const actionButtons = game.createActionButtons();
  await message.edit({ embeds: [gameEmbed], files: [attachment], components: [actionButtons] });
  // Si mode solo et c'est le tour du bot, le faire jouer
  if (game.isSoloMode) {
    setTimeout(async () => {
      const currentPlayer = game.getCurrentPlayer();
      if (currentPlayer && currentPlayer.id === 'UNO_BOT_AI') {
        await playBotTurn(game, message);
      }
    }, 1000);
  }
  
  // Si c'est encore au tour du bot (apr√®s un +2/+4), rejouer
  const newCurrentPlayer = game.getCurrentPlayer();
  if (newCurrentPlayer.id === 'UNO_BOT_AI') {
    await playBotTurn(game, message);
  }
}

class UnoGame {
  constructor(channelId, creatorId) {
    this.channelId = channelId;
    this.creatorId = creatorId;
    this.players = [];
    this.deck = [];
    this.discardPile = [];
    this.currentPlayerIndex = 0;
    this.direction = 1;
    this.started = false;
    this.drawCount = 0;
    this.messageId = null;
    this.collector = null;
    // ‚ú® NOUVEAU: GameId unique pour identifier cette partie (sans underscore pour √©viter les conflits)
    this.gameId = `${channelId}${Date.now()}`.substring(0, 20); // Max 20 chars pour customId
  }

  addPlayer(userId, username) {
    if (this.started) return false;
    if (this.players.find(p => p.id === userId)) return false;
    if (this.players.length >= 10) return false;
    
    this.players.push({
      id: userId,
      username: username,
      hand: []
    });
    return true;
  }

  removePlayer(userId) {
    const index = this.players.findIndex(p => p.id === userId);
    if (index === -1) return false;
    
    this.players.splice(index, 1);
    
    if (this.currentPlayerIndex >= this.players.length) {
      this.currentPlayerIndex = 0;
    }
    
    return true;
  }

  createDeck() {
    this.deck = [];
    const colors = ['red', 'blue', 'green', 'yellow'];
    
    for (const color of colors) {
      this.deck.push({ type: 'number', color, value: 0 });
      for (let i = 1; i <= 9; i++) {
        this.deck.push({ type: 'number', color, value: i });
        this.deck.push({ type: 'number', color, value: i });
      }
    }
    
    for (const color of colors) {
      for (let i = 0; i < 2; i++) {
        this.deck.push({ type: 'skip', color });
        this.deck.push({ type: 'reverse', color });
        this.deck.push({ type: 'draw2', color });
      }
    }
    
    for (let i = 0; i < 4; i++) {
      this.deck.push({ type: 'wild', color: null });
      this.deck.push({ type: 'wild_draw4', color: null });
    }
    
    this.shuffle(this.deck);
  }

  shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
  }

  dealCards() {
    for (const player of this.players) {
      player.hand = [];
      for (let i = 0; i < 7; i++) {
        player.hand.push(this.deck.pop());
      }
    }
    
    let startCard;
    do {
      startCard = this.deck.pop();
    } while (startCard.type !== 'number');
    
    this.discardPile.push(startCard);
  }

  drawCard(player) {
    if (this.deck.length === 0) {
      const topCard = this.discardPile.pop();
      this.deck = [...this.discardPile];
      this.shuffle(this.deck);
      this.discardPile = [topCard];
    }
    
    if (this.deck.length > 0) {
      const card = this.deck.pop();
      player.hand.push(card);
      return card;
    }
    return null;
  }

  canPlayCard(card, topCard) {
    if (card.type === 'wild' || card.type === 'wild_draw4') return true;
    if (card.color === topCard.color) return true;
    
    const topColor = topCard.chosenColor || topCard.color;
    if (card.color === topColor) return true;
    
    if (card.type === 'number' && topCard.type === 'number' && card.value === topCard.value) return true;
    if (card.type === topCard.type && card.type !== 'number') return true;
    
    return false;
  }

  playCard(playerId, cardIndex, chosenColor = null) {
    const player = this.players[this.currentPlayerIndex];
    if (player.id !== playerId) return { success: false, error: "Ce n est pas votre tour !" };
    
    if (cardIndex < 0 || cardIndex >= player.hand.length) {
      return { success: false, error: "Carte invalide !" };
    }
    
    const card = player.hand[cardIndex];
    const topCard = this.discardPile[this.discardPile.length - 1];
    
    // Si drawCount > 0, on ne peut jouer que +2 ou +4 pour cumuler
    if (this.drawCount > 0) {
      if (card.type !== 'draw2' && card.type !== 'wild_draw4') {
        return { success: false, error: `Vous devez piocher ${this.drawCount} carte(s) ou jouer un +2/+4 !` };
      }
    }
    
    if (!this.canPlayCard(card, topCard)) {
      return { success: false, error: "Cette carte ne peut pas etre jouee !" };
    }
    
    if ((card.type === 'wild' || card.type === 'wild_draw4') && !chosenColor) {
      return { success: false, error: "Vous devez choisir une couleur !", requireColor: true };
    }
    
    player.hand.splice(cardIndex, 1);
    
    if (chosenColor) {
      card.chosenColor = chosenColor;
    }
    
    this.discardPile.push(card);
    
    if (player.hand.length === 0) {
      return { success: true, winner: player };
    }
    
    let skipNext = false;
    
    switch (card.type) {
      case 'skip':
        skipNext = true;
        break;
      
      case 'reverse':
        if (this.players.length === 2) {
          skipNext = true;
        } else {
          this.direction *= -1;
        }
        break;
      
      case 'draw2':
        this.drawCount += 2;
        skipNext = true;
        break;
      
      case 'wild_draw4':
        this.drawCount += 4;
        skipNext = true;
        break;
    }
    
    this.nextPlayer(skipNext);
    
    return { success: true };
  }

  nextPlayer(skip = false) {
    this.currentPlayerIndex += this.direction;
    
    if (this.currentPlayerIndex >= this.players.length) {
      this.currentPlayerIndex = 0;
    } else if (this.currentPlayerIndex < 0) {
      this.currentPlayerIndex = this.players.length - 1;
    }
    
    // Si skip et drawCount = 0, on passe encore au suivant
    if (skip && this.drawCount === 0) {
      this.nextPlayer(false);
    }
    // Si drawCount > 0, on NE passe PAS au suivant : le joueur doit piocher
  }

  getCardDisplay(card) {
    return getCardVisual(card);
  }

  getCurrentPlayer() {
    return this.players[this.currentPlayerIndex];
  }

  getTopCard() {
    return this.discardPile[this.discardPile.length - 1];
  }

  createGameEmbed() {
    const topCard = this.getTopCard();
    const currentPlayer = this.getCurrentPlayer();
    
    // Liste des joueurs avec ic√¥nes de statut (style UnoOnDisc)
    const playersList = this.players.map((p, i) => {
      const isCurrentPlayer = i === this.currentPlayerIndex;
      const statusIcon = isCurrentPlayer ? "üü¢" : "‚ö™";
      const cardIcon = "üé¥";
      return `${statusIcon} **${p.username}**\n${cardIcon} √ó${p.hand.length} ${this.getCardDisplay(topCard)}`;
    }).join("\n\n");
    
    const cardImagePath = getCardImagePath(topCard);
    const attachment = new AttachmentBuilder(cardImagePath, { name: 'current_card.png' });
    
    // Message de tour avec mention
    let tourMessage = `√Ä <@${currentPlayer.id}> de jouer !`;
    if (this.drawCount > 0) {
      tourMessage += ` ‚Ä¢ **Pioche: ${this.drawCount}**`;
    }
    
    const embed = new EmbedBuilder()
      .setColor("#57F287") // Vert Discord
      .setDescription(playersList + "\n\n" + tourMessage)
      .setThumbnail('attachment://current_card.png')
      .setFooter({ text: `Pioche: ${this.deck.length} cartes` });
    return { embed, attachment };
  }

  // ‚ú® NOUVEAU: Boutons avec gameId
  createActionButtons() {
    const row = new ActionRowBuilder()
      .addComponents(
        new ButtonBuilder()
          .setCustomId(`uno_${this.gameId}_hand`)
          .setLabel("üÉè Ma main")
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId(`uno_${this.gameId}_draw`)
          .setLabel("üé¥ Piocher")
          .setStyle(ButtonStyle.Secondary),
        new ButtonBuilder()
          .setCustomId(`uno_${this.gameId}_quit`)
          .setLabel("üö™ Quitter")
          .setStyle(ButtonStyle.Danger)
      );
    return row;
  }
}

module.exports = {
  name: "uno",
  data: new SlashCommandBuilder()
    .setName("uno")
    .setDescription("Jouer au UNO avec de vraies cartes !"),

  async execute(interaction) {
    const channelId = interaction.channelId;
    
    if (activeGames.has(channelId)) {
      return interaction.reply({ content: "‚ùå Une partie est deja en cours !", ephemeral: true });
    }
    
    const game = new UnoGame(channelId, interaction.user.id);
    game.addPlayer(interaction.user.id, interaction.user.username);
    activeGames.set(channelId, game);
    
    const lobbyEmbed = new EmbedBuilder()
      .setColor("#00FF00")
      .setTitle("üéÆ Nouvelle Partie UNO")
      .setDescription(`${interaction.user.username} a cree une partie !\n\n**Cliquez sur "Rejoindre"**\n*Minimum 2 joueurs*`)
      .addFields({ name: "üë• Joueurs (1/10)", value: `1Ô∏è‚É£ ${interaction.user.username}` })
      .setFooter({ text: "Le createur peut demarrer la partie" });
    
    // ‚ú® NOUVEAU: Boutons avec gameId
    const lobbyButtons = new ActionRowBuilder()
      .addComponents(
        new ButtonBuilder().setCustomId(`uno_${game.gameId}_join`).setLabel("‚úÖ Rejoindre").setStyle(ButtonStyle.Success),
        new ButtonBuilder().setCustomId(`uno_${game.gameId}_solo`).setLabel("ü§ñ Solo vs Robot").setStyle(ButtonStyle.Secondary),
        new ButtonBuilder().setCustomId(`uno_${game.gameId}_start`).setLabel("üöÄ Demarrer").setStyle(ButtonStyle.Primary),
        new ButtonBuilder().setCustomId(`uno_${game.gameId}_cancel`).setLabel("‚ùå Annuler").setStyle(ButtonStyle.Danger)
      );
    
    const message = await interaction.reply({ embeds: [lobbyEmbed], components: [lobbyButtons], fetchReply: true });
    game.messageId = message.id;
    
    // ‚ú® NOUVEAU: Channel Collector avec filtre par gameId
    const channel = interaction.channel;
    const collector = channel.createMessageComponentCollector({
      filter: i => i.customId.startsWith(`uno_${game.gameId}_`),
      time: 300000
    });
    game.collector = collector;
    
    collector.on("collect", async i => {
      // Extraire l'action en retirant le pr√©fixe
      const action = i.customId.replace(`uno_${game.gameId}_`, '');
      
      if (action === "join") {
        const success = game.addPlayer(i.user.id, i.user.username);
        if (!success) {
          if (game.started) return i.reply({ content: "‚ùå Partie commencee !", ephemeral: true });
          if (game.players.find(p => p.id === i.user.id)) return i.reply({ content: "‚ùå Deja dans la partie !", ephemeral: true });
          return i.reply({ content: "‚ùå Partie pleine !", ephemeral: true });
        }
        const numbers = ["1Ô∏è‚É£","2Ô∏è‚É£","3Ô∏è‚É£","4Ô∏è‚É£","5Ô∏è‚É£","6Ô∏è‚É£","7Ô∏è‚É£","8Ô∏è‚É£","9Ô∏è‚É£","üîü"];
        const playerList = game.players.map((p, idx) => `${numbers[idx]} ${p.username}`).join("\n");
        lobbyEmbed.spliceFields(0, 1, { name: `üë• Joueurs (${game.players.length}/10)`, value: playerList });
        await i.update({ embeds: [lobbyEmbed], components: [lobbyButtons] });
      } else if (action === "solo") {
        // Mode Solo vs Robot
        game.addPlayer('UNO_BOT_AI', 'ü§ñ Robot UNO');
        game.isSoloMode = true; // Marquer comme mode solo
        
        // D√©marrer automatiquement avec 2 joueurs (user + bot)
        game.started = true;
        game.createDeck();
        game.dealCards();
        const { embed: gameEmbed, attachment } = game.createGameEmbed();
        const actionButtons = game.createActionButtons();
        await i.update({ embeds: [gameEmbed], files: [attachment], components: [actionButtons] });
        
        collector.stop();
        
        // Lancer le gameCollector pour le mode solo
        setupGameCollectorForSolo(channel, message, game, channelId);
      } else if (action === "start") {
        if (game.creatorId !== i.user.id) return i.reply({ content: "‚ùå Seul le createur peut demarrer !", ephemeral: true });
        if (game.players.length < 2) return i.reply({ content: "‚ùå Minimum 2 joueurs !", ephemeral: true });
        game.started = true;
        game.createDeck();
        game.dealCards();
        const { embed: gameEmbed, attachment } = game.createGameEmbed();
        const actionButtons = game.createActionButtons();
        await i.update({ embeds: [gameEmbed], files: [attachment], components: [actionButtons] });
        setupGameCollector(channel, message, game, channelId);
      } else if (action === "cancel") {
        if (game.creatorId !== i.user.id) return i.reply({ content: "‚ùå Seul le createur peut annuler !", ephemeral: true });
        activeGames.delete(channelId);
        collector.stop();
        await i.update({ content: "üõë Partie annulee.", embeds: [], components: [] });
      }
    });
    
    collector.on("end", () => {
      if (activeGames.has(channelId) && !activeGames.get(channelId).started) {
        activeGames.delete(channelId);
      }
    });
  }
};


// Setup pour mode Solo vs Robot
function setupGameCollectorForSolo(channel, message, game, channelId) {
  // D'abord setup le collector normal
  setupGameCollector(channel, message, game, channelId);
  
  // Si c'est le tour du bot au d√©marrage, le faire jouer
  setTimeout(async () => {
    const currentPlayer = game.getCurrentPlayer();
    if (currentPlayer && currentPlayer.id === 'UNO_BOT_AI') {
      await playBotTurn(game, message);
    }
  }, 1000);
}

function setupGameCollector(channel, message, game, channelId) {
  // ‚ú® NOUVEAU: Channel Collector avec filtre par gameId
  const gameCollector = channel.createMessageComponentCollector({
    filter: i => i.customId.startsWith(`uno_${game.gameId}_`),
    time: 1800000
  });
  
  gameCollector.on("collect", async i => {
    const player = game.players.find(p => p.id === i.user.id);
    if (!player) return i.reply({ content: "‚ùå Pas dans la partie !", ephemeral: true });
    
    // Extraire l'action en retirant le pr√©fixe
    const action = i.customId.replace(`uno_${game.gameId}_`, '');
    
    if (action === "hand") {
      // Note: On ne peut pas supprimer les anciens messages √©ph√©m√®res
      // Mais ce n'est pas grave, ils ne sont visibles que par le joueur
      
      // Cr√©er l'image composite de la main
      const handImageBuffer = await createHandImage(player.hand);
      const handAttachment = new AttachmentBuilder(handImageBuffer, { name: 'hand.png' });
      
      // R√©cup√©rer les infos du jeu
      const currentPlayer = game.getCurrentPlayer();
      const topCard = game.getTopCard();
      
      // Image de la carte actuelle pour le thumbnail
      const topCardImagePath = getCardImagePath(topCard);
      const topCardAttachment = new AttachmentBuilder(topCardImagePath, { name: 'current_card.png' });
      
      // Liste des joueurs (comme dans l'embed principal)
      const playersList = game.players.map((p, i) => {
        const isCurrentPlayer = i === game.currentPlayerIndex;
        const statusIcon = isCurrentPlayer ? "üü¢" : "‚ö™";
        const cardIcon = "üé¥";
        return `${statusIcon} **${p.username}** ${cardIcon} √ó${p.hand.length}`;
      }).join("\n");
      
      // Message d'avertissement si p√©nalit√©
      let description = `**üë• Joueurs**\n${playersList}`;
      
      if (player.id === currentPlayer.id && game.drawCount > 0) {
        description += `\n\n‚ö†Ô∏è **P√©nalit√©: ${game.drawCount} carte(s) √† piocher**\nJouez +2 ou +4 pour cumuler !`;
      }
      
      description += `\n\n√Ä <@${currentPlayer.id}> de jouer !`;
      
      // Infos du jeu
      const sensIcon = game.direction === 1 ? "üîΩ" : "üîº";
      const gameInfo = `${sensIcon} Sens ${game.direction === 1 ? "‚Üì" : "‚Üë"}  ‚Ä¢  üìö ${game.deck.length} cartes  ‚Ä¢  ${player.hand.length} carte(s) dans votre main`;
      
      const handEmbed = new EmbedBuilder()
        .setColor(player.id === currentPlayer.id ? "#57F287" : "#99AAB5")
        .setTitle("üéÆ UNO - Votre Main")
        .setDescription(description)
        .setThumbnail('attachment://current_card.png')
        .setImage('attachment://hand.png')
        .setFooter({ text: gameInfo });
      
      // ‚ú® NOUVEAU: Boutons avec gameId
      const rows = [];
      for (let idx = 0; idx < Math.min(player.hand.length, 25); idx += 5) {
        const row = new ActionRowBuilder();
        for (let j = idx; j < Math.min(idx + 5, player.hand.length); j++) {
          const card = player.hand[j];
          const emoji = game.getCardDisplay(card);
          row.addComponents(
            new ButtonBuilder()
              .setCustomId(`uno_${game.gameId}_play_${j}`)
              .setLabel(`${j + 1}`)
              .setEmoji(emoji)
              .setStyle(ButtonStyle.Primary)
          );
        }
        rows.push(row);
      }
      
      const handMsg = await i.reply({ embeds: [handEmbed], files: [topCardAttachment, handAttachment], components: rows, ephemeral: true, fetchReply: true });
      
      // ‚ú® NOUVEAU: Channel Collector avec filtre par gameId
      const handCollector = channel.createMessageComponentCollector({
        filter: hi => hi.customId.startsWith(`uno_${game.gameId}_`) && hi.user.id === player.id,
        time: 600000
      });
      
      handCollector.on("collect", async handInteraction => {
        // Defer IMM√âDIATEMENT pour √©viter timeout (3 sec Discord)
        if (!handInteraction.deferred && !handInteraction.replied) {
          await handInteraction.deferReply({ ephemeral: true }).catch(err => {
            console.error('[UNO] Defer √©chou√©:', err.message);
          });
        }
        
        if (handInteraction.customId.startsWith(`uno_${game.gameId}_play_`)) {
          const cardIndex = parseInt(handInteraction.customId.replace(`uno_${game.gameId}_play_`, ''));
          const currentPlayer = game.getCurrentPlayer();
          
          if (currentPlayer.id !== handInteraction.user.id) {
            return handInteraction.editReply({ content: "‚ùå Pas votre tour !" });
          }
          
          const card = player.hand[cardIndex];
          
          if (card && (card.type === "wild" || card.type === "wild_draw4")) {
            // ‚ú® NOUVEAU: Boutons couleur avec gameId
            const colorRow = new ActionRowBuilder()
              .addComponents(
                new ButtonBuilder().setCustomId(`uno_${game.gameId}_color_${cardIndex}_red`).setLabel("üî¥ Rouge").setStyle(ButtonStyle.Danger),
                new ButtonBuilder().setCustomId(`uno_${game.gameId}_color_${cardIndex}_blue`).setLabel("üîµ Bleu").setStyle(ButtonStyle.Primary),
                new ButtonBuilder().setCustomId(`uno_${game.gameId}_color_${cardIndex}_green`).setLabel("üü¢ Vert").setStyle(ButtonStyle.Success),
                new ButtonBuilder().setCustomId(`uno_${game.gameId}_color_${cardIndex}_yellow`).setLabel("üü° Jaune").setStyle(ButtonStyle.Secondary)
              );
            const colorMsg = await handInteraction.editReply({ content: `Joker ${game.getCardDisplay(card)}. Choisissez une couleur:`, components: [colorRow], fetchReply: true });
            
            // ‚ú® NOUVEAU: Channel Collector pour couleur avec filtre par gameId
            const colorCollector = channel.createMessageComponentCollector({
              filter: ci => ci.customId.startsWith(`uno_${game.gameId}_color_`) && ci.user.id === player.id,
              time: 120000
            });
            
            colorCollector.on("collect", async colorInteraction => {
              if (colorInteraction.customId.startsWith(`uno_${game.gameId}_color_`)) {
                const parts = colorInteraction.customId.replace(`uno_${game.gameId}_color_`, '').split('_');
                const cardIdx = parseInt(parts[0]);
                const color = parts[1];
                const result = game.playCard(colorInteraction.user.id, cardIdx, color);
                if (!result.success) return colorInteraction.reply({ content: `‚ùå ${result.error}`, ephemeral: true });
                
                if (result.winner) {
                  activeGames.delete(channelId);
                  gameCollector.stop();
                  handCollector.stop();
                  colorCollector.stop();
                  const winEmbed = new EmbedBuilder().setColor("#FFD700").setTitle("üéâ VICTOIRE !").setDescription(`${result.winner.username} a gagne !`);
                  await colorInteraction.update({ content: "‚úÖ Joker joue - VICTOIRE !", components: [] });
                  return message.edit({ embeds: [winEmbed], components: [], files: [] });
                }
                
                // Mettre √† jour l'affichage de la main apr√®s joker
                const jokerHandImageBuffer = await createHandImage(player.hand);
                const jokerHandAttachment = new AttachmentBuilder(jokerHandImageBuffer, { name: 'hand.png' });
                
                const jokerCurrentPlayer = game.getCurrentPlayer();
                const jokerTopCard = game.getTopCard();
                
                // Image de la carte actuelle pour le thumbnail
                const jokerTopCardImagePath = getCardImagePath(jokerTopCard);
                const jokerTopCardAttachment = new AttachmentBuilder(jokerTopCardImagePath, { name: 'current_card.png' });
                
                // Liste des joueurs apr√®s joker
                const jokerPlayersList = game.players.map((p, i) => {
                  const isCurrentPlayer = i === game.currentPlayerIndex;
                  const statusIcon = isCurrentPlayer ? "üü¢" : "‚ö™";
                  const cardIcon = "üé¥";
                  return `${statusIcon} **${p.username}** ${cardIcon} √ó${p.hand.length}`;
                }).join("\n");
                
                let jokerDescription = `**üë• Joueurs**\n${jokerPlayersList}`;
                
                if (player.id === jokerCurrentPlayer.id && game.drawCount > 0) {
                  jokerDescription += `\n\n‚ö†Ô∏è **P√©nalit√©: ${game.drawCount} carte(s) √† piocher**\nJouez +2 ou +4 pour cumuler !`;
                }
                
                jokerDescription += `\n\n√Ä <@${jokerCurrentPlayer.id}> de jouer !`;
                
                const jokerSensIcon = game.direction === 1 ? "üîΩ" : "üîº";
                const jokerGameInfo = `${jokerSensIcon} Sens ${game.direction === 1 ? "‚Üì" : "‚Üë"}  ‚Ä¢  üìö ${game.deck.length} cartes  ‚Ä¢  ${player.hand.length} carte(s) dans votre main`;
                
                const jokerUpdatedEmbed = new EmbedBuilder()
                  .setColor(player.id === jokerCurrentPlayer.id ? "#57F287" : "#99AAB5")
                  .setTitle("üéÆ UNO - Votre Main")
                  .setDescription(jokerDescription)
                  .setThumbnail('attachment://current_card.png')
                  .setImage('attachment://hand.png')
                  .setFooter({ text: jokerGameInfo });
                
                const jokerNewRows = [];
                for (let idx = 0; idx < Math.min(player.hand.length, 25); idx += 5) {
                  const row = new ActionRowBuilder();
                  for (let j = idx; j < Math.min(idx + 5, player.hand.length); j++) {
                    const card = player.hand[j];
                    const emoji = game.getCardDisplay(card);
                    row.addComponents(
                      new ButtonBuilder()
                        .setCustomId(`uno_${game.gameId}_play_${j}`)
                        .setLabel(`${j + 1}`)
                        .setEmoji(emoji)
                        .setStyle(ButtonStyle.Primary)
                    );
                  }
                  jokerNewRows.push(row);
                }
                
                await colorInteraction.update({ 
                  content: "‚úÖ Joker jou√© ! Votre main a √©t√© mise √† jour.", 
                  embeds: [jokerUpdatedEmbed],
                  files: [jokerTopCardAttachment, jokerHandAttachment],
                  components: jokerNewRows 
                });
                
                const { embed: gameEmbed, attachment } = game.createGameEmbed();
                const actionButtons = game.createActionButtons();
                await message.edit({ embeds: [gameEmbed], files: [attachment], components: [actionButtons] });
                // Si mode solo et c'est le tour du bot, le faire jouer
                if (game.isSoloMode) {
                  setTimeout(async () => {
                    const currentPlayer = game.getCurrentPlayer();
                    if (currentPlayer && currentPlayer.id === 'UNO_BOT_AI') {
                      await playBotTurn(game, message);
                    }
                  }, 1000);
                }
              }
            });
            
            return;
          }
          
          const result = game.playCard(handInteraction.user.id, cardIndex);
          if (!result.success) return handInteraction.editReply({ content: `‚ùå ${result.error}` });
          
          if (result.winner) {
            activeGames.delete(channelId);
            gameCollector.stop();
            handCollector.stop();
            const winEmbed = new EmbedBuilder().setColor("#FFD700").setTitle("üéâ VICTOIRE !").setDescription(`${result.winner.username} a gagne !\n\nüèÜ Felicitations !`);
            await handInteraction.editReply({ content: "‚úÖ Victoire !" });
            return message.edit({ embeds: [winEmbed], components: [], files: [] });
          }
          
          // Mettre √† jour l'affichage de la main automatiquement
          const newHandImageBuffer = await createHandImage(player.hand);
          const newHandAttachment = new AttachmentBuilder(newHandImageBuffer, { name: 'hand.png' });
          
          const newCurrentPlayer = game.getCurrentPlayer();
          const newTopCard = game.getTopCard();
          
          // Image de la carte actuelle pour le thumbnail
          const newTopCardImagePath = getCardImagePath(newTopCard);
          const newTopCardAttachment = new AttachmentBuilder(newTopCardImagePath, { name: 'current_card.png' });
          
          // Liste des joueurs mise √† jour
          const newPlayersList = game.players.map((p, i) => {
            const isCurrentPlayer = i === game.currentPlayerIndex;
            const statusIcon = isCurrentPlayer ? "üü¢" : "‚ö™";
            const cardIcon = "üé¥";
            return `${statusIcon} **${p.username}** ${cardIcon} √ó${p.hand.length}`;
          }).join("\n");
          
          let newDescription = `**üë• Joueurs**\n${newPlayersList}`;
          
          if (player.id === newCurrentPlayer.id && game.drawCount > 0) {
            newDescription += `\n\n‚ö†Ô∏è **P√©nalit√©: ${game.drawCount} carte(s) √† piocher**\nJouez +2 ou +4 pour cumuler !`;
          }
          
          newDescription += `\n\n√Ä <@${newCurrentPlayer.id}> de jouer !`;
          
          const newSensIcon = game.direction === 1 ? "üîΩ" : "üîº";
          const newGameInfo = `${newSensIcon} Sens ${game.direction === 1 ? "‚Üì" : "‚Üë"}  ‚Ä¢  üìö ${game.deck.length} cartes  ‚Ä¢  ${player.hand.length} carte(s) dans votre main`;
          
          const updatedHandEmbed = new EmbedBuilder()
            .setColor(player.id === newCurrentPlayer.id ? "#57F287" : "#99AAB5")
            .setTitle("üéÆ UNO - Votre Main")
            .setDescription(newDescription)
            .setThumbnail('attachment://current_card.png')
            .setImage('attachment://hand.png')
            .setFooter({ text: newGameInfo });
          
          // Recr√©er les boutons pour la main mise √† jour
          const newRows = [];
          for (let idx = 0; idx < Math.min(player.hand.length, 25); idx += 5) {
            const row = new ActionRowBuilder();
            for (let j = idx; j < Math.min(idx + 5, player.hand.length); j++) {
              const card = player.hand[j];
              const emoji = game.getCardDisplay(card);
              row.addComponents(
                new ButtonBuilder()
                  .setCustomId(`uno_${game.gameId}_play_${j}`)
                  .setLabel(`${j + 1}`)
                  .setEmoji(emoji)
                  .setStyle(ButtonStyle.Primary)
              );
            }
            newRows.push(row);
          }
          
          await handInteraction.editReply({ 
            content: '‚úÖ Carte jou√©e ! Votre main a √©t√© mise √† jour.',
            embeds: [updatedHandEmbed],
            files: [newTopCardAttachment, newHandAttachment],
            components: newRows
          });
          
          // Mettre √† jour l'embed principal
          const { embed: gameEmbed, attachment } = game.createGameEmbed();
          const actionButtons = game.createActionButtons();
          await message.edit({ embeds: [gameEmbed], files: [attachment], components: [actionButtons] });
          // Si mode solo et c'est le tour du bot, le faire jouer
          if (game.isSoloMode) {
            setTimeout(async () => {
              const currentPlayer = game.getCurrentPlayer();
              if (currentPlayer && currentPlayer.id === 'UNO_BOT_AI') {
                await playBotTurn(game, message);
              }
            }, 1000);
          }
          
          // User peut recliquer sur "Ma main" pour voir sa main mise √† jour
        }
      });
      
    } else if (action === "draw") {
      const currentPlayer = game.getCurrentPlayer();
      if (currentPlayer.id !== i.user.id) return i.reply({ content: "‚ùå Pas votre tour !", ephemeral: true });
      
      // Si drawCount > 0, piocher toutes les cartes de p√©nalit√©
      if (game.drawCount > 0) {
        const drawnCards = [];
        for (let idx = 0; idx < game.drawCount; idx++) {
          const card = game.drawCard(player);
          if (card) drawnCards.push(game.getCardDisplay(card));
        }
        const cardsList = drawnCards.join(' ');
        game.drawCount = 0;
        game.nextPlayer();
        await i.reply({ content: `‚úÖ Pioche de penalite: ${drawnCards.length} carte(s) piochees\n${cardsList}\n\nVous avez ${player.hand.length} cartes`, ephemeral: true });
      } else {
        // Pioche normale (1 carte)
        const card = game.drawCard(player);
        game.nextPlayer();
        await i.reply({ content: `‚úÖ Pioche: ${game.getCardDisplay(card)}\n\nVous avez ${player.hand.length} cartes`, ephemeral: true });
      }
      
      const { embed: gameEmbed, attachment } = game.createGameEmbed();
      const actionButtons = game.createActionButtons();
      await message.edit({ embeds: [gameEmbed], files: [attachment], components: [actionButtons] });
      // Si mode solo et c'est le tour du bot, le faire jouer
      if (game.isSoloMode) {
        setTimeout(async () => {
          const currentPlayer = game.getCurrentPlayer();
          if (currentPlayer && currentPlayer.id === 'UNO_BOT_AI') {
            await playBotTurn(game, message);
          }
        }, 1000);
      }
      
      } else if (action === "quit") {
      // En mode solo, arr√™ter compl√®tement le jeu
      if (game.isSoloMode) {
        activeGames.delete(channelId);
        gameCollector.stop();
        await i.update({ content: "üõë Partie Solo annul√©e.", embeds: [], components: [] });
        return;
      }
      
      // Mode multi-joueurs: retirer le joueur normalement
      game.removePlayer(i.user.id);
      await i.reply({ content: "‚úÖ Vous avez quitte.", ephemeral: true });
      if (game.players.length === 0) {
        activeGames.delete(channelId);
        gameCollector.stop();
        return message.edit({ content: "üõë Partie annulee (plus de joueurs).", embeds: [], components: [] });
      }
      const { embed: gameEmbed, attachment } = game.createGameEmbed();
      const actionButtons = game.createActionButtons();
      await message.edit({ embeds: [gameEmbed], files: [attachment], components: [actionButtons] });
      // Si mode solo et c'est le tour du bot, le faire jouer
      if (game.isSoloMode) {
        setTimeout(async () => {
          const currentPlayer = game.getCurrentPlayer();
          if (currentPlayer && currentPlayer.id === 'UNO_BOT_AI') {
            await playBotTurn(game, message);
          }
        }, 1000);
      }
    }
  });
  
  gameCollector.on("end", () => {
    if (activeGames.has(channelId)) {
      activeGames.delete(channelId);
    }
  });
}
