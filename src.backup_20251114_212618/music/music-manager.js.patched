// Syst√®me de musique avec r√©p√©tition et connexion permanente
const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
const {
  joinVoiceChannel,
  createAudioPlayer,
  createAudioResource,
  AudioPlayerStatus,
  StreamType,
  NoSubscriberBehavior
} = require('@discordjs/voice');
const play = require('play-dl');
const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');

const YTDLP_PATH = '/home/bagbot/yt-dlp';
const FFMPEG_PATH = require('ffmpeg-static');

class CustomMusicManager {
  constructor(client) {
    this.client = client;
    this.queues = new Map();
    
    this.playlistsPath = path.join(__dirname, '../data/playlists');
    this.uploadsPath = path.join(__dirname, '../../data/uploads');
    
    if (!fs.existsSync(this.playlistsPath)) fs.mkdirSync(this.playlistsPath, { recursive: true });
    if (!fs.existsSync(this.uploadsPath)) fs.mkdirSync(this.uploadsPath, { recursive: true });
    
    console.log('[CustomMusic] ‚úÖ Syst√®me musique initialis√© (avec r√©p√©tition + connexion 24/7)');
    
    this.client.on('interactionCreate', async interaction => {
      if (!interaction.isButton()) return;
      if (!interaction.customId.startsWith('music_')) return;
      await this.handleButton(interaction);
    });
  }
  
  getQueue(guildId) {
    if (!this.queues.has(guildId)) {
      this.queues.set(guildId, {
        tracks: [],
        current: null,
        connection: null,
        player: null,
        channel: null,
        volume: 80,
        playerMessage: null,
        repeatMode: 'off', // 'off', 'queue', 'one'
        originalQueue: [] // Pour repeat queue
      });
    }
    return this.queues.get(guildId);
  }
  
  async play(interaction, query) {
    try {
      const member = interaction.member;
      const voiceChannel = member.voice.channel;
      
      if (!voiceChannel) {
        return interaction.reply({ 
          content: '‚ùå Vous devez √™tre dans un salon vocal !', 
          ephemeral: true 
        });
      }
      
      await interaction.deferReply();
      
      console.log('[CustomMusic] Recherche:', query);
      
      let track;
      
      if (play.yt_validate(query) === 'video') {
        const info = await play.video_info(query);
        track = {
          title: info.video_details.title,
          author: info.video_details.channel.name,
          url: info.video_details.url,
          duration: this.formatDuration(info.video_details.durationInSec),
          thumbnail: info.video_details.thumbnails[0].url,
          requestedBy: interaction.user
        };
      } else {
        const results = await play.search(query, { limit: 1 });
        
        if (results.length === 0) {
          return interaction.editReply('‚ùå Aucun r√©sultat trouv√© !');
        }
        
        const video = results[0];
        track = {
          title: video.title,
          author: video.channel.name,
          url: video.url,
          duration: this.formatDuration(video.durationInSec),
          thumbnail: video.thumbnails[0].url,
          requestedBy: interaction.user
        };
      }
      
      console.log('[CustomMusic] ‚úÖ Trouv√©:', track.title);
      
      const queue = this.getQueue(interaction.guild.id);
      queue.tracks.push(track);
      queue.channel = interaction.channel;
      
      if (!queue.current) {
        await this.processQueue(interaction.guild, voiceChannel);
        return interaction.editReply('üéµ Lecture d√©marr√©e !');
      } else {
        return interaction.editReply(`‚úÖ **Ajout√© √† la file (#${queue.tracks.length}):** ${track.title}`);
      }
      
    } catch (error) {
      console.error('[CustomMusic] Erreur play:', error);
      return interaction.editReply({ 
        content: '‚ùå Erreur: ' + error.message 
      });
    }
  }
  
  async processQueue(guild, voiceChannel) {
    const queue = this.getQueue(guild.id);
    
    if (queue.tracks.length === 0 && queue.repeatMode === 'off') {
      queue.current = null;
      console.log('[CustomMusic] File vide, mais reste connect√© 24/7');
      
      if (queue.playerMessage) {
        const embed = new EmbedBuilder()
          .setColor(0x00FF00)
          
          .setThumbnail(guild.iconURL())
          
          ;
        
        await queue.playerMessage.edit({ embeds: [embed], components: [] }).catch(() => {});
      }
      
      // NE PAS d√©connecter - rester 24/7
      return;
    }
    
    // Gestion de la r√©p√©tition
    if (queue.tracks.length === 0 && queue.repeatMode === 'queue' && queue.originalQueue.length > 0) {
      console.log('[CustomMusic] üîÅ R√©p√©tition de la file');
      queue.tracks = [...queue.originalQueue];
    }
    
    if (queue.repeatMode === 'one' && queue.current) {
      console.log('[CustomMusic] üîÇ R√©p√©tition de la musique actuelle');
      // Rejouer la m√™me musique
    } else if (queue.tracks.length > 0) {
      queue.current = queue.tracks.shift();
      console.log('[CustomMusic] Lecture:', queue.current.title);
      console.log('[CustomMusic] File restante:', queue.tracks.length);
      
      // Sauvegarder la queue originale pour repeat
      if (queue.repeatMode === 'queue' && queue.originalQueue.length === 0) {
        queue.originalQueue = [queue.current, ...queue.tracks];
      }
    } else if (!queue.current) {
      return; // Rien √† jouer
    }
    
    // V√©rifier si la connexion existe ET est valide
    const isConnectionValid = queue.connection && 
                             queue.connection.state && 
                             queue.connection.state.status !== VoiceConnectionStatus.Destroyed &&
                             queue.connection.state.status !== VoiceConnectionStatus.Disconnected;
    
    if (!isConnectionValid) {
      console.log('[CustomMusic] Cr√©ation/recr√©ation de la connexion vocale...');
      
      // D√©truire l'ancienne connexion si elle existe
      if (queue.connection) {
        try {
          queue.connection.destroy();
        } catch (e) {}
      }
      
      queue.connection = joinVoiceChannel({
        channelId: voiceChannel.id,
        guildId: guild.id,
        adapterCreator: guild.voiceAdapterCreator
      });
      
      queue.player = createAudioPlayer({
        behaviors: {
          noSubscriber: NoSubscriberBehavior.Play
        }
      });
      
      queue.connection.subscribe(queue.player);
      queue.voiceChannel = voiceChannel;
      
      queue.player.on(AudioPlayerStatus.Idle, () => {
        console.log('[CustomMusic] Piste termin√©e');
        this.processQueue(guild, voiceChannel);
      });
      
      queue.player.on('error', error => {
        console.error('[CustomMusic] ‚ùå Erreur player:', error);
        queue.channel?.send('‚ùå Erreur de lecture');
        this.processQueue(guild, voiceChannel);
      });
      
      console.log('[CustomMusic] ‚úÖ Connect√© 24/7 au salon vocal');
    } else {
      console.log('[CustomMusic] Connexion vocale d√©j√† active');
    }
    try {
      // V√©rifier si c'est un fichier local ou YouTube
      if (queue.current.isLocal && queue.current.localPath) {
        console.log('[CustomMusic] Lecture fichier local:', queue.current.localPath);
        
        if (!fs.existsSync(queue.current.localPath)) {
          throw new Error('Fichier introuvable: ' + queue.current.localPath);
        }
        
        // Streamer le fichier local directement avec FFmpeg
        const ffmpegProcess = spawn(FFMPEG_PATH, [
          '-i', queue.current.localPath,
          '-analyzeduration', '0',
          '-loglevel', 'error',  // Chang√© pour voir les erreurs
          '-f', 's16le',
          '-ar', '48000',
          '-ac', '2',
          'pipe:1'
        ], {
          stdio: ['pipe', 'pipe', 'pipe']
        });NaN, (err) => {
          console.error('[CustomMusic] ‚ùå Erreur FFmpeg local:', err);
        });
        
        const resource = createAudioResource(ffmpegProcess.stdout, {
          inputType: StreamType.Raw,
          inlineVolume: true
        });
        
        resource.volume.setVolume(queue.volume / 100);
        undefined('[CustomMusic] ‚úÖ Lecture fichier local d√©marr√©e');
        
      } else {
        console.log('[CustomMusic] Streaming YouTube:', queue.current.url);
        
        const ytdlpProcess = spawn(YTDLP_PATH, [
          '-f', 'bestaudio',
          '-o', '-',
          queue.current.url
        ]);
      
      const ffmpegProcess = spawn(FFMPEG_PATH, [
        '-i', 'pipe:0',
        '-analyzeduration', '0',
        '-loglevel', '0',
        '-f', 's16le',
        '-ar', '48000',
        '-ac', '2',
        'pipe:1'
      ], {
        stdio: ['pipe', 'pipe', 'pipe']
      });
      
        ytdlpProcess.stdout.pipe(ffmpegProcess.stdin);
        
        const resource = createAudioResource(ffmpegProcess.stdout, {
          inputType: StreamType.Raw,
          inlineVolume: true
        });
        
        resource.volume.setVolume(queue.volume / 100);
        queue.player.play(resource);
        
        console.log('[CustomMusic] ‚úÖ Lecture YouTube d√©marr√©e');
      }
      
      await this.displayPlayer(guild, queue);
      
    } catch (error) {
      console.error('[CustomMusic] ‚ùå Erreur:', error);
      queue.channel?.send('‚ùå Erreur lors de la lecture de: ' + queue.current.title);
      this.processQueue(guild, voiceChannel);
    }
  }
  
  async displayPlayer(guild, queue) {
    if (!queue.channel) return;
    
    let repeatIcon = '';
    if (queue.repeatMode === 'queue') repeatIcon = 'üîÅ ';
    if (queue.repeatMode === 'one') repeatIcon = 'üîÇ ';
    
    // Design : LOGO DU SERVEUR EN GROS
    const embed = new EmbedBuilder()
      .setColor(0xE91E63)
      //       
      .setImage(guild.iconURL({ size: 1024 }))  // LOGO DU SERVEUR EN TR√àS GROS
      .addFields([
        { name: 'üéµ Titre', value: queue.current?.title || 'Aucune musique', inline: false },
        { name: 'üë§ Artiste', value: queue.current?.author || 'Inconnu', inline: true },
        { name: '‚è±Ô∏è Dur√©e', value: queue.current?.duration || '0:00', inline: true },
        { name: 'üîä Volume', value: `${queue.volume}%`, inline: true },
        { name: 'üìã File', value: `${queue.tracks.length} piste(s)`, inline: true }
      ]);
    
    const row1 = new ActionRowBuilder()
      .addComponents(
        new ButtonBuilder()
          .setCustomId('music_pause')
          .setEmoji('‚è∏Ô∏è')
          .setLabel('Pause')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId('music_skip')
          .setEmoji('‚è≠Ô∏è')
          .setLabel('Skip')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId('music_stop')
          .setEmoji('‚èπÔ∏è')
          .setLabel('Stop')
          .setStyle(ButtonStyle.Danger),
        new ButtonBuilder()
          .setCustomId('music_volumedown')
          .setEmoji('üîâ')
          .setLabel('-10%')
          .setStyle(ButtonStyle.Secondary),
        new ButtonBuilder()
          .setCustomId('music_volumeup')
          .setEmoji('üîä')
          .setLabel('+10%')
          .setStyle(ButtonStyle.Secondary)
      );
    
    const row2 = new ActionRowBuilder()
      .addComponents(
        new ButtonBuilder()
          .setCustomId('music_repeatone')
          .setEmoji('üîÇ')
          .setLabel('R√©p√©ter 1')
          .setStyle(queue.repeatMode === 'one' ? ButtonStyle.Success : ButtonStyle.Secondary),
        new ButtonBuilder()
          .setCustomId('music_repeatqueue')
          .setEmoji('üîÅ')
          .setLabel('R√©p√©ter file')
          .setStyle(queue.repeatMode === 'queue' ? ButtonStyle.Success : ButtonStyle.Secondary)
      );
    
    if (queue.playerMessage) {
      try {
        await queue.playerMessage.delete();
      } catch (e) {}
    }
    
    queue.playerMessage = await queue.channel.send({ 
      embeds: [embed], 
      components: [row1, row2] 
    });
  }
  
  async handleButton(interaction) {
    const queue = this.getQueue(interaction.guild.id);
    const action = interaction.customId.replace('music_', '');
    
    if (!queue.player && action !== 'repeatone' && action !== 'repeatqueue') {
      return interaction.reply({ 
        content: '‚ùå Aucune musique en cours !', 
        ephemeral: true 
      });
    }
    
    switch (action) {
      case 'pause':
        if (queue.player.state.status === AudioPlayerStatus.Playing) {
          queue.player.pause();
          await interaction.reply({ content: '‚è∏Ô∏è **Pause**', ephemeral: true });
        } else {
          queue.player.unpause();
          await interaction.reply({ content: '‚ñ∂Ô∏è **Reprise**', ephemeral: true });
        }
        break;
        
      case 'skip':
        queue.player.stop();
        await interaction.reply({ content: '‚è≠Ô∏è **Musique suivante**', ephemeral: true });
        break;
        
      case 'stop':
        queue.tracks = [];
        queue.originalQueue = [];
        queue.current = null;
        queue.repeatMode = 'off';
        queue.player.stop();
        await interaction.reply({ content: '‚èπÔ∏è **Arr√™t√© (bot reste connect√©)**', ephemeral: true });
        break;
        
      case 'volumedown':
        queue.volume = Math.max(0, queue.volume - 10);
        if (queue.player?.state?.resource?.volume) {
          queue.player.state.resource.volume.setVolume(queue.volume / 100);
          console.log(`[Volume] Baiss√© √† ${queue.volume}%`);
        } else {
          console.warn('[Volume] Resource volume non disponible');
        }
        await interaction.reply({ content: `üîâ Volume: ${queue.volume}%`, ephemeral: true });
        await this.updatePlayerEmbed(interaction.guild, queue);
        break;
        
      case 'volumeup':
        queue.volume = Math.min(200, queue.volume + 10);
        if (queue.player?.state?.resource?.volume) {
          queue.player.state.resource.volume.setVolume(queue.volume / 100);
          console.log(`[Volume] Augment√© √† ${queue.volume}%`);
        } else {
          console.warn('[Volume] Resource volume non disponible');
        }
        await interaction.reply({ content: `üîä Volume: ${queue.volume}%`, ephemeral: true });
        await this.updatePlayerEmbed(interaction.guild, queue);
        break;
        
      case 'repeatone':
        if (queue.repeatMode === 'one') {
          queue.repeatMode = 'off';
          await interaction.reply({ content: 'üîÇ **R√©p√©tition d√©sactiv√©e**', ephemeral: true });
        } else {
          queue.repeatMode = 'one';
          queue.originalQueue = [];
          await interaction.reply({ content: 'üîÇ **R√©p√©tition d\'une musique activ√©e**', ephemeral: true });
        }
        await this.updatePlayerEmbed(interaction.guild, queue);
        break;
        
      case 'repeatqueue':
        if (queue.repeatMode === 'queue') {
          queue.repeatMode = 'off';
          queue.originalQueue = [];
          await interaction.reply({ content: 'üîÅ **R√©p√©tition d√©sactiv√©e**', ephemeral: true });
        } else {
          queue.repeatMode = 'queue';
          queue.originalQueue = queue.current ? [queue.current, ...queue.tracks] : [...queue.tracks];
          await interaction.reply({ content: 'üîÅ **R√©p√©tition de la file activ√©e**', ephemeral: true });
        }
        await this.updatePlayerEmbed(interaction.guild, queue);
        break;
    }
  }
  
  async updatePlayerEmbed(guild, queue) {
    if (!queue.playerMessage || !queue.current) return;
    
    let repeatIcon = '';
    if (queue.repeatMode === 'queue') repeatIcon = 'üîÅ ';
    if (queue.repeatMode === 'one') repeatIcon = 'üîÇ ';
    
    const embed = EmbedBuilder.from(queue.playerMessage.embeds[0]);
    embed.setAuthor({ 
      name: repeatIcon + 'üéµ Lecteur Musique BAG', 
      iconURL: guild.iconURL() 
    });
    
    const fields = embed.data.fields;
    const volumeIdx = fields.findIndex(f => f.name === 'üîä Volume');
    const repeatIdx = fields.findIndex(f => f.name === 'üîÅ R√©p√©tition');
    
    if (volumeIdx !== -1) {
      fields[volumeIdx].value = `${queue.volume}%`;
    }
    
    if (repeatIdx !== -1) {
      fields[repeatIdx].value = queue.repeatMode === 'off' ? 'D√©sactiv√©e' : queue.repeatMode === 'one' ? 'Une musique' : 'File enti√®re';
    }
    
    const row2 = ActionRowBuilder.from(queue.playerMessage.components[1]);
    row2.components[0].setStyle(queue.repeatMode === 'one' ? ButtonStyle.Success : ButtonStyle.Secondary);
    row2.components[1].setStyle(queue.repeatMode === 'queue' ? ButtonStyle.Success : ButtonStyle.Secondary);
    
    try {
      await queue.playerMessage.edit({ 
        embeds: [embed],
        components: [queue.playerMessage.components[0], row2]
      });
    } catch (e) {}
  }
  
  async pause(interaction) {
    const queue = this.getQueue(interaction.guild.id);
    if (!queue.player) {
      return interaction.reply({ content: '‚ùå Aucune musique en cours !', ephemeral: true });
    }
    queue.player.pause();
    return interaction.reply('‚è∏Ô∏è **Lecture mise en pause**');
  }
  
  async resume(interaction) {
    const queue = this.getQueue(interaction.guild.id);
    if (!queue.player) {
      return interaction.reply({ content: '‚ùå Aucune musique en cours !', ephemeral: true });
    }
    queue.player.unpause();
    return interaction.reply('‚ñ∂Ô∏è **Lecture reprise**');
  }
  
  async skip(interaction) {
    const queue = this.getQueue(interaction.guild.id);
    if (!queue.player || !queue.current) {
      return interaction.reply({ content: '‚ùå Aucune musique en cours !', ephemeral: true });
    }
    const current = queue.current;
    queue.player.stop();
    return interaction.reply(`‚è≠Ô∏è **Musique pass√©e:** ${current.title}`);
  }
  
  async stop(interaction) {
    const queue = this.getQueue(interaction.guild.id);
    if (!queue.connection) {
      return interaction.reply({ content: '‚ùå Aucune musique en cours !', ephemeral: true });
    }
    queue.tracks = [];
    queue.originalQueue = [];
    queue.current = null;
    queue.repeatMode = 'off';
    queue.player.stop();
    return interaction.reply('‚èπÔ∏è **Lecture arr√™t√©e (bot reste connect√© 24/7)**');
  }
  
  async queue(interaction) {
    const queue = this.getQueue(interaction.guild.id);
    if (!queue.current) {
      return interaction.reply({ content: '‚ùå Aucune musique en cours !', ephemeral: true });
    }
    
    const embed = new EmbedBuilder()
      .setColor(0xE91E63)
      
      .setThumbnail(interaction.guild.iconURL())
      
      ;
    
    if (queue.tracks.length > 0) {
      const queueList = queue.tracks.slice(0, 10).map((track, i) => 
        `${i + 1}. ${track.title} - \`${track.duration}\``
      ).join('\n');
      
      embed.addFields([{ name: 'üìã Suivant(s)', value: queueList }]);
    }
    
    return interaction.reply({ embeds: [embed] });
  }
  
  formatDuration(seconds) {
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = seconds % 60;
    
    if (h > 0) return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    return `${m}:${s.toString().padStart(2, '0')}`;
  }

  // M√©thode pour jouer des fichiers locaux (playlists personnalis√©es)
  async playLocal(interaction, track, voiceChannel, isFirst = false) {
    const uploadsPath = path.join(__dirname, '../../data/uploads');
    const queue = this.getQueue(interaction.guild.id);
    
    // Cr√©er l'objet track avec le chemin local
    const localTrack = {
      title: track.title || track.filename || 'Musique locale',
      author: track.author || 'Playlist personnalis√©e',
      url: null, // Pas d'URL
      localPath: path.join(uploadsPath, track.filename),
      duration: track.duration || '?:??',
      thumbnail: track.thumbnail || null,
      requestedBy: interaction.user,
      isLocal: true
    };
    
    queue.tracks.push(localTrack);
    queue.channel = interaction.channel;
    
    if (!queue.current && isFirst) {
      await this.processQueue(interaction.guild, voiceChannel);
    }
  }

}



module.exports = { CustomMusicManager };
