// Syst√®me de musique avec r√©p√©tition et connexion permanente
const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
const {
  joinVoiceChannel,
  createAudioPlayer,
  createAudioResource,
  AudioPlayerStatus,
  VoiceConnectionStatus,
  StreamType,
  NoSubscriberBehavior
} = require('@discordjs/voice');
const play = require('play-dl');
const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');

const YTDLP_PATH = '/home/bagbot/yt-dlp';
const FFMPEG_PATH = require('ffmpeg-static');

class CustomMusicManager {
  constructor(client) {
    this.client = client;
    this.queues = new Map();
    
    this.playlistsPath = path.join(__dirname, '../data/playlists');
    this.uploadsPath = path.join(__dirname, '../../data/uploads');
    
    if (!fs.existsSync(this.playlistsPath)) fs.mkdirSync(this.playlistsPath, { recursive: true });
    if (!fs.existsSync(this.uploadsPath)) fs.mkdirSync(this.uploadsPath, { recursive: true });
    
    console.log('[CustomMusic] ‚úÖ Syst√®me musique initialis√© (avec r√©p√©tition + connexion 24/7)');
    
    this.client.on('interactionCreate', async interaction => {
      if (!interaction.isButton()) return;
      if (!interaction.customId.startsWith('music_')) return;
      await this.handleButton(interaction);
    });
  }
  
  getQueue(guildId) {
    if (!this.queues.has(guildId)) {
      this.queues.set(guildId, {
        tracks: [],
        current: null,
        connection: null,
        player: null,
        channel: null,
        volume: 80,
        playerMessage: null,
        repeatMode: 'off', // 'off', 'queue', 'one'
        originalQueue: [], // Pour repeat queue
        history: [] // Pour le bouton previous
      });
    }
    return this.queues.get(guildId);
  }
  
  async play(interaction, query) {
    try {
      const member = interaction.member;
      const voiceChannel = member.voice.channel;
      
      if (!voiceChannel) {
        return interaction.reply({ 
          content: '‚ùå Vous devez √™tre dans un salon vocal !', 
          ephemeral: true 
        });
      }
      
      await interaction.deferReply();
      
      console.log('[CustomMusic] Recherche:', query);
      
      let track;
      
      if (play.yt_validate(query) === 'video') {
        const info = await play.video_info(query);
        track = {
          title: info.video_details.title,
          author: info.video_details.channel.name,
          url: info.video_details.url,
          duration: this.formatDuration(info.video_details.durationInSec),
          thumbnail: info.video_details.thumbnails[0].url,
          requestedBy: interaction.user
        };
      } else {
        // Essayer play.search d'abord, puis fallback vers yt-dlp
        let video;
        try {
          console.log('[CustomMusic] Recherche avec play-dl...');
          const results = await play.search(query, { limit: 1 });
          if (results.length > 0) {
            video = results[0];
          } else {
            throw new Error('Aucun r√©sultat avec play-dl');
          }
        } catch (playError) {
          console.log('[CustomMusic] play-dl √©chou√©, utilisation de yt-dlp...', playError.message);
          
          // Fallback: utiliser yt-dlp pour la recherche
          console.log('[CustomMusic] üîÑ Lancement yt-dlp...');
          video = await new Promise((resolve, reject) => {
            const ytdlp = spawn(YTDLP_PATH, [
              '--dump-json',
              '--default-search', 'ytsearch1',
              '--no-playlist',
              '--no-warnings',
              '--',
              query
            ]);

            let stdout = '';
            let stderr = '';
            let resolved = false;
            
            ytdlp.stdout.on('data', (d) => { 
              stdout += d.toString(); 
              console.log('[CustomMusic] yt-dlp stdout size:', stdout.length);
            });
            
            ytdlp.stderr.on('data', (d) => { 
              stderr += d.toString(); 
            });
            
            ytdlp.on('close', (code) => {
              if (resolved) return;
              resolved = true;
              
              console.log('[CustomMusic] yt-dlp termin√©, code:', code, 'stdout:', stdout.length, 'bytes');
              
              if (code !== 0) {
                console.error('[CustomMusic] yt-dlp stderr:', stderr);
                return reject(new Error('Recherche yt-dlp √©chou√©e (code ' + code + ')'));
              }
              
              if (!stdout.trim()) {
                console.error('[CustomMusic] yt-dlp: stdout vide!');
                return reject(new Error('Aucun r√©sultat yt-dlp'));
              }
              
              try {
                const lines = stdout.trim().split('\n');
                const data = JSON.parse(lines[lines.length - 1]);
                console.log('[CustomMusic] yt-dlp pars√©:', data.title);
                resolve({
                  title: data.title,
                  channel: { name: data.uploader || data.channel || 'Inconnu' },
                  url: data.webpage_url || data.url,
                  durationInSec: data.duration || 0,
                  thumbnails: [{ url: data.thumbnail || '' }]
                });
              } catch (e) {
                console.error('[CustomMusic] Parse error:', e.message, 'stdout preview:', stdout.substring(0, 200));
                reject(new Error('Parse error: ' + e.message));
              }
            });
            
            ytdlp.on('error', (err) => {
              if (resolved) return;
              resolved = true;
              console.error('[CustomMusic] yt-dlp spawn error:', err);
              reject(new Error('Erreur spawn yt-dlp: ' + err.message));
            });
            
            const timeout = setTimeout(() => { 
              if (resolved) return;
              resolved = true;
              console.error('[CustomMusic] yt-dlp timeout apr√®s 60s');
              ytdlp.kill(); 
              reject(new Error('Timeout yt-dlp (60s)')); 
            }, 60000);
            
            ytdlp.on('close', () => clearTimeout(timeout));
          });
          
          console.log('[CustomMusic] ‚úÖ yt-dlp trouv√©:', video.title);
        }
        
        if (!video) {
          return interaction.editReply('‚ùå Aucun r√©sultat trouv√© !');
        }
        
        track = {
          title: video.title,
          author: video.channel.name,
          url: video.url,
          duration: this.formatDuration(video.durationInSec),
          thumbnail: video.thumbnails[0].url,
          requestedBy: interaction.user
        };
      }
      
      console.log('[CustomMusic] ‚úÖ Trouv√©:', track.title);
      
      const queue = this.getQueue(interaction.guild.id);
      queue.tracks.push(track);
      queue.channel = interaction.channel;
      
      if (!queue.current) {
        await this.processQueue(interaction.guild, voiceChannel);
        return interaction.editReply('üéµ Lecture d√©marr√©e !');
      } else {
        return interaction.editReply(`‚úÖ **Ajout√© √† la file (#${queue.tracks.length}):** ${track.title}`);
      }
      
    } catch (error) {
      console.error('[CustomMusic] Erreur play:', error);
      return interaction.editReply({ 
        content: '‚ùå Erreur: ' + error.message 
      });
    }
  }
  
  async processQueue(guild, voiceChannel, isPrevious = false) {
    const queue = this.getQueue(guild.id);
    
    if (queue.tracks.length === 0 && queue.repeatMode === 'off' && !isPrevious) {
      queue.current = null;
      console.log('[CustomMusic] File vide, mais reste connect√© 24/7');
      
      if (queue.playerMessage) {
        const embed = new EmbedBuilder()
          .setColor(0x00FF00)
          .setAuthor({ name: 'üéµ Lecteur Musique BAG - File vide', iconURL: guild.iconURL() })
          .setDescription('La file d\'attente est vide. Utilisez `/play` pour ajouter des musiques.')
          .setThumbnail(guild.iconURL());
        
        await queue.playerMessage.edit({ embeds: [embed], components: [] }).catch(() => {});
      }
      
      // NE PAS d√©connecter - rester 24/7
      return;
    }
    
    // Gestion de la r√©p√©tition
    if (queue.tracks.length === 0 && queue.repeatMode === 'queue' && queue.originalQueue.length > 0) {
      console.log('[CustomMusic] üîÅ R√©p√©tition de la file');
      queue.tracks = [...queue.originalQueue];
    }
    
    if (!isPrevious) {
      // Sauvegarder la musique actuelle dans l'historique avant de passer √† la suivante
      if (queue.current) {
        queue.history.push(queue.current);
        // Limiter l'historique √† 20 musiques
        if (queue.history.length > 20) {
          queue.history.shift();
        }
      }
      
      if (queue.repeatMode === 'one' && queue.current) {
        console.log('[CustomMusic] üîÇ R√©p√©tition de la musique actuelle');
        // Rejouer la m√™me musique (ne pas la retirer de current)
      } else if (queue.tracks.length > 0) {
        queue.current = queue.tracks.shift();
        console.log('[CustomMusic] Lecture:', queue.current.title);
        console.log('[CustomMusic] File restante:', queue.tracks.length);
        
        // Sauvegarder la queue originale pour repeat
        if (queue.repeatMode === 'queue' && queue.originalQueue.length === 0) {
          queue.originalQueue = [queue.current, ...queue.tracks];
        }
      } else if (!queue.current) {
        return; // Rien √† jouer
      }
    }
    // Si isPrevious = true, queue.current contient d√©j√† la musique pr√©c√©dente
    
    // V√©rifier si la connexion existe ET est valide
    const isConnectionValid = queue.connection && 
                             queue.connection.state && 
                             queue.connection.state.status !== VoiceConnectionStatus.Destroyed &&
                             queue.connection.state.status !== VoiceConnectionStatus.Disconnected;
    
    if (!isConnectionValid) {
      console.log('[CustomMusic] Cr√©ation/recr√©ation de la connexion vocale...');
      
      // D√©truire l'ancienne connexion si elle existe
      if (queue.connection) {
        try {
          queue.connection.destroy();
        } catch (e) {}
      }
      
      queue.connection = joinVoiceChannel({
        channelId: voiceChannel.id,
        guildId: guild.id,
        adapterCreator: guild.voiceAdapterCreator
      });
      
      queue.player = createAudioPlayer({
        behaviors: {
          noSubscriber: NoSubscriberBehavior.Play
        }
      });
      
      queue.connection.subscribe(queue.player);
      queue.voiceChannel = voiceChannel;
      
      queue.player.on(AudioPlayerStatus.Idle, () => {
        console.log('[CustomMusic] Piste termin√©e');
        this.processQueue(guild, voiceChannel);
      });
      
      queue.player.on('error', error => {
        console.error('[CustomMusic] ‚ùå Erreur player:', error);
        queue.channel?.send('‚ùå Erreur de lecture');
        this.processQueue(guild, voiceChannel);
      });
      
      console.log('[CustomMusic] ‚úÖ Connect√© 24/7 au salon vocal');
    } else {
      console.log('[CustomMusic] Connexion vocale d√©j√† active');
    }
    
    try {
      // V√©rifier si c'est un fichier local ou YouTube
      if (queue.current.isLocal && queue.current.localPath) {
        console.log('[CustomMusic] Lecture fichier local:', queue.current.localPath);
        
        if (!fs.existsSync(queue.current.localPath)) {
          throw new Error('Fichier introuvable: ' + queue.current.localPath);
        }
        
        // Streamer le fichier local - Configuration optimis√©e anti-√©cho
        const ffmpegProcess = spawn(FFMPEG_PATH, [
          '-i', queue.current.localPath,
          '-analyzeduration', '10M',
          '-loglevel', 'error',
          '-vn',
          // Configuration SIMPLE anti-pumping
          '-af', 'highpass=f=60,lowpass=f=16000,alimiter=limit=0.9:attack=7:release=100:level=false',
          '-f', 's16le',
          '-ar', '48000',
          '-ac', '2',
          '-acodec', 'pcm_s16le',
          'pipe:1'
        ]);
        
        ffmpegProcess.on('error', (err) => {
          console.error('[CustomMusic] ‚ùå Erreur FFmpeg local:', err);
        });
        
        const resource = createAudioResource(ffmpegProcess.stdout, {
          inputType: StreamType.Raw,
          inlineVolume: true
        });
        
        resource.volume.setVolume(queue.volume / 100);
        queue.player.play(resource);
        
        console.log('[CustomMusic] ‚úÖ Lecture fichier local d√©marr√©e');
        console.log('[Volume] Volume initial:', queue.volume + '%');
        
      } else {
        console.log('[CustomMusic] Streaming YouTube:', queue.current.url);
        
        const ytdlpProcess = spawn(YTDLP_PATH, [
          '-f', 'bestaudio[ext=webm]/bestaudio[ext=m4a]/bestaudio',
          '--audio-quality', '0',
          '-o', '-',
          queue.current.url
        ]);
      
        const ffmpegProcess = spawn(FFMPEG_PATH, [
          '-i', 'pipe:0',
          '-analyzeduration', '10M',
          '-loglevel', 'error',
          '-vn',
          // Configuration SIMPLE anti-pumping
          '-af', 'highpass=f=60,lowpass=f=16000,alimiter=limit=0.9:attack=7:release=100:level=false',
          '-f', 's16le',
          '-ar', '48000',
          '-ac', '2',
          '-acodec', 'pcm_s16le',
          'pipe:1'
        ]);
      
        ytdlpProcess.stdout.pipe(ffmpegProcess.stdin);
        
        ytdlpProcess.on('error', (err) => {
          console.error('[CustomMusic] ‚ùå Erreur yt-dlp:', err);
        });
        
        const resource = createAudioResource(ffmpegProcess.stdout, {
          inputType: StreamType.Raw,
          inlineVolume: true
        });
        
        resource.volume.setVolume(queue.volume / 100);
        queue.player.play(resource);
        
        console.log('[CustomMusic] ‚úÖ Lecture YouTube d√©marr√©e');
        console.log('[Volume] Volume initial:', queue.volume + '%');
      }
      
      await this.displayPlayer(guild, queue);
      
    } catch (error) {
      console.error('[CustomMusic] ‚ùå Erreur:', error);
      queue.channel?.send('‚ùå Erreur lors de la lecture de: ' + queue.current.title);
      this.processQueue(guild, voiceChannel);
    }
  }
  
  async displayPlayer(guild, queue) {
    if (!queue.channel) return;
    
    let repeatIcon = '';
    if (queue.repeatMode === 'queue') repeatIcon = 'üîÅ ';
    if (queue.repeatMode === 'one') repeatIcon = 'üîÇ ';
    
    // Design : LOGO DU SERVEUR EN GROS
    const embed = new EmbedBuilder()
      .setColor(0xE91E63)
      .setAuthor({ name: repeatIcon + 'üéµ Lecteur Musique BAG', iconURL: guild.iconURL() })
      .setImage(guild.iconURL({ size: 1024 }))  // LOGO DU SERVEUR EN TR√àS GROS
      .addFields([
        { name: 'üéµ Titre', value: queue.current?.title || 'Aucune musique', inline: false },
        { name: 'üë§ Artiste', value: queue.current?.author || 'Inconnu', inline: true },
        { name: '‚è±Ô∏è Dur√©e', value: queue.current?.duration || '0:00', inline: true },
        { name: 'üîä Volume', value: `${queue.volume}%`, inline: true },
        { name: 'üìã File', value: `${queue.tracks.length} piste(s)`, inline: true }
      ]);
    
    const row1 = new ActionRowBuilder()
      .addComponents(
        new ButtonBuilder()
          .setCustomId('music_previous')
          .setEmoji('‚èÆÔ∏è')
          .setLabel('Pr√©c√©dent')
          .setStyle(ButtonStyle.Primary)
          .setDisabled(queue.history.length === 0),
        new ButtonBuilder()
          .setCustomId('music_pause')
          .setEmoji('‚è∏Ô∏è')
          .setLabel('Pause')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId('music_skip')
          .setEmoji('‚è≠Ô∏è')
          .setLabel('Skip')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId('music_stop')
          .setEmoji('‚èπÔ∏è')
          .setLabel('Stop')
          .setStyle(ButtonStyle.Danger)
      );
    
    const row2 = new ActionRowBuilder()
      .addComponents(
        new ButtonBuilder()
          .setCustomId('music_volumedown')
          .setEmoji('üîâ')
          .setLabel('-10%')
          .setStyle(ButtonStyle.Secondary),
        new ButtonBuilder()
          .setCustomId('music_volumeup')
          .setEmoji('üîä')
          .setLabel('+10%')
          .setStyle(ButtonStyle.Secondary),
        new ButtonBuilder()
          .setCustomId('music_repeatone')
          .setEmoji('üîÇ')
          .setLabel('R√©p√©ter 1')
          .setStyle(queue.repeatMode === 'one' ? ButtonStyle.Success : ButtonStyle.Secondary),
        new ButtonBuilder()
          .setCustomId('music_repeatqueue')
          .setEmoji('üîÅ')
          .setLabel('R√©p√©ter file')
          .setStyle(queue.repeatMode === 'queue' ? ButtonStyle.Success : ButtonStyle.Secondary)
      );
    
    if (queue.playerMessage) {
      try {
        await queue.playerMessage.delete();
      } catch (e) {}
    }
    
    queue.playerMessage = await queue.channel.send({ 
      embeds: [embed], 
      components: [row1, row2] 
    });
  }
  
  async handleButton(interaction) {
    const queue = this.getQueue(interaction.guild.id);
    const action = interaction.customId.replace('music_', '');
    
    if (!queue.player && action !== 'repeatone' && action !== 'repeatqueue') {
      return interaction.reply({ 
        content: '‚ùå Aucune musique en cours !', 
        ephemeral: true 
      });
    }
    
    switch (action) {
      case 'pause':
        if (queue.player.state.status === AudioPlayerStatus.Playing) {
          queue.player.pause();
          await interaction.reply({ content: '‚è∏Ô∏è **Pause**', ephemeral: true });
        } else {
          queue.player.unpause();
          await interaction.reply({ content: '‚ñ∂Ô∏è **Reprise**', ephemeral: true });
        }
        break;
        
      case 'skip':
        // CORRECTION : Forcer le passage √† la suivante, m√™me en mode repeat one
        if (queue.repeatMode === 'one') {
          // D√©sactiver temporairement le mode repeat one pour passer √† la suivante
          const wasRepeatOne = true;
          queue.repeatMode = 'off';
          queue.player.stop();
          // Ne pas r√©activer repeat one, l'utilisateur voulait passer √† la suivante
          await interaction.reply({ content: '‚è≠Ô∏è **Musique suivante** (mode r√©p√©tition d√©sactiv√©)', ephemeral: true });
        } else {
          queue.player.stop();
          await interaction.reply({ content: '‚è≠Ô∏è **Musique suivante**', ephemeral: true });
        }
        break;
        
      case 'previous':
        // NOUVEAU : Bouton pr√©c√©dent
        if (queue.history.length === 0) {
          return interaction.reply({ content: '‚ùå Aucune musique pr√©c√©dente !', ephemeral: true });
        }
        
        // Remettre la musique actuelle dans la file
        if (queue.current) {
          queue.tracks.unshift(queue.current);
        }
        
        // R√©cup√©rer la derni√®re musique de l'historique
        queue.current = queue.history.pop();
        
        // Arr√™ter la lecture actuelle et relancer avec la musique pr√©c√©dente
        queue.player.stop();
        
        // Utiliser un flag pour indiquer qu'on va backward
        const voiceChannel = queue.voiceChannel || interaction.member.voice.channel;
        await this.processQueue(interaction.guild, voiceChannel, true);
        
        await interaction.reply({ content: '‚èÆÔ∏è **Musique pr√©c√©dente**', ephemeral: true });
        break;
        
      case 'stop':
        // CORRECTION : R√©initialiser proprement tout en gardant la connexion
        queue.tracks = [];
        queue.originalQueue = [];
        queue.repeatMode = 'off';
        queue.history = [];
        
        // Arr√™ter le player proprement
        if (queue.player && queue.player.state.status !== AudioPlayerStatus.Idle) {
          queue.player.stop(true); // Force l'arr√™t
        }
        
        queue.current = null;
        
        await interaction.reply({ content: '‚èπÔ∏è **Arr√™t√© (bot reste connect√©)**', ephemeral: true });
        
        // Mettre √† jour l'affichage
        if (queue.playerMessage) {
          const embed = new EmbedBuilder()
            .setColor(0x00FF00)
            .setAuthor({ name: 'üéµ Lecteur Musique BAG - Arr√™t√©', iconURL: interaction.guild.iconURL() })
            .setDescription('Le lecteur est arr√™t√©. Utilisez `/play` pour d√©marrer une nouvelle musique.')
            .setThumbnail(interaction.guild.iconURL());
          
          await queue.playerMessage.edit({ embeds: [embed], components: [] }).catch(() => {});
        }
        break;
        
      case 'volumedown':
        queue.volume = Math.max(0, queue.volume - 10);
        console.log(`[Volume] Tentative de baisse √† ${queue.volume}%`);
        
        // V√©rifier diff√©rents chemins d'acc√®s au volume
        let volumeSet = false;
        
        if (queue.player && queue.player.state && queue.player.state.resource) {
          const res = queue.player.state.resource;
          if (res.volume && typeof res.volume.setVolume === 'function') {
            res.volume.setVolume(queue.volume / 100);
            volumeSet = true;
            console.log(`[Volume] ‚úÖ Baiss√© √† ${queue.volume}% via state.resource.volume`);
          }
        }
        
        if (!volumeSet) {
          console.warn('[Volume] ‚ö†Ô∏è Impossible de modifier le volume en temps r√©el');
        }
        
        await interaction.reply({ content: `üîâ Volume: ${queue.volume}%`, ephemeral: true });
        await this.updatePlayerEmbed(interaction.guild, queue);
        break;
        
      case 'volumeup':
        queue.volume = Math.min(200, queue.volume + 10);
        console.log(`[Volume] Tentative d'augmentation √† ${queue.volume}%`);
        
        // V√©rifier diff√©rents chemins d'acc√®s au volume
        let volumeSetUp = false;
        
        if (queue.player && queue.player.state && queue.player.state.resource) {
          const res = queue.player.state.resource;
          if (res.volume && typeof res.volume.setVolume === 'function') {
            res.volume.setVolume(queue.volume / 100);
            volumeSetUp = true;
            console.log(`[Volume] ‚úÖ Augment√© √† ${queue.volume}% via state.resource.volume`);
          }
        }
        
        if (!volumeSetUp) {
          console.warn('[Volume] ‚ö†Ô∏è Impossible de modifier le volume en temps r√©el');
        }
        
        await interaction.reply({ content: `üîä Volume: ${queue.volume}%`, ephemeral: true });
        await this.updatePlayerEmbed(interaction.guild, queue);
        break;
        
      case 'repeatone':
        if (queue.repeatMode === 'one') {
          queue.repeatMode = 'off';
          await interaction.reply({ content: 'üîÇ **R√©p√©tition d√©sactiv√©e**', ephemeral: true });
        } else {
          queue.repeatMode = 'one';
          queue.originalQueue = [];
          await interaction.reply({ content: 'üîÇ **R√©p√©tition d\'une musique activ√©e**', ephemeral: true });
        }
        await this.updatePlayerEmbed(interaction.guild, queue);
        break;
        
      case 'repeatqueue':
        if (queue.repeatMode === 'queue') {
          queue.repeatMode = 'off';
          queue.originalQueue = [];
          await interaction.reply({ content: 'üîÅ **R√©p√©tition d√©sactiv√©e**', ephemeral: true });
        } else {
          queue.repeatMode = 'queue';
          queue.originalQueue = queue.current ? [queue.current, ...queue.tracks] : [...queue.tracks];
          await interaction.reply({ content: 'üîÅ **R√©p√©tition de la file activ√©e**', ephemeral: true });
        }
        await this.updatePlayerEmbed(interaction.guild, queue);
        break;
    }
  }
  
  async updatePlayerEmbed(guild, queue) {
    if (!queue.playerMessage || !queue.current) return;
    
    let repeatIcon = '';
    if (queue.repeatMode === 'queue') repeatIcon = 'üîÅ ';
    if (queue.repeatMode === 'one') repeatIcon = 'üîÇ ';
    
    const embed = EmbedBuilder.from(queue.playerMessage.embeds[0]);
    embed.setAuthor({ 
      name: repeatIcon + 'üéµ Lecteur Musique BAG', 
      iconURL: guild.iconURL() 
    });
    
    const fields = embed.data.fields;
    const volumeIdx = fields.findIndex(f => f.name === 'üîä Volume');
    
    if (volumeIdx !== -1) {
      fields[volumeIdx].value = `${queue.volume}%`;
    }
    
    const row1 = ActionRowBuilder.from(queue.playerMessage.components[0]);
    // Mettre √† jour le bouton previous
    row1.components[0].setDisabled(queue.history.length === 0);
    
    const row2 = ActionRowBuilder.from(queue.playerMessage.components[1]);
    row2.components[2].setStyle(queue.repeatMode === 'one' ? ButtonStyle.Success : ButtonStyle.Secondary);
    row2.components[3].setStyle(queue.repeatMode === 'queue' ? ButtonStyle.Success : ButtonStyle.Secondary);
    
    try {
      await queue.playerMessage.edit({ 
        embeds: [embed],
        components: [row1, row2]
      });
    } catch (e) {}
  }
  
  async pause(interaction) {
    const queue = this.getQueue(interaction.guild.id);
    if (!queue.player) {
      return interaction.reply({ content: '‚ùå Aucune musique en cours !', ephemeral: true });
    }
    queue.player.pause();
    return interaction.reply('‚è∏Ô∏è **Lecture mise en pause**');
  }
  
  async resume(interaction) {
    const queue = this.getQueue(interaction.guild.id);
    if (!queue.player) {
      return interaction.reply({ content: '‚ùå Aucune musique en cours !', ephemeral: true });
    }
    queue.player.unpause();
    return interaction.reply('‚ñ∂Ô∏è **Lecture reprise**');
  }
  
  async skip(interaction) {
    const queue = this.getQueue(interaction.guild.id);
    if (!queue.player || !queue.current) {
      return interaction.reply({ content: '‚ùå Aucune musique en cours !', ephemeral: true });
    }
    const current = queue.current;
    
    // Forcer le passage √† la suivante m√™me en mode repeat
    if (queue.repeatMode === 'one') {
      queue.repeatMode = 'off';
    }
    
    queue.player.stop();
    return interaction.reply(`‚è≠Ô∏è **Musique pass√©e:** ${current.title}`);
  }
  
  async stop(interaction) {
    const queue = this.getQueue(interaction.guild.id);
    if (!queue.connection) {
      return interaction.reply({ content: '‚ùå Aucune musique en cours !', ephemeral: true });
    }
    queue.tracks = [];
    queue.originalQueue = [];
    queue.history = [];
    queue.current = null;
    queue.repeatMode = 'off';
    
    if (queue.player && queue.player.state.status !== AudioPlayerStatus.Idle) {
      queue.player.stop(true);
    }
    
    return interaction.reply('‚èπÔ∏è **Lecture arr√™t√©e (bot reste connect√© 24/7)**');
  }
  
  async queue(interaction) {
    const queue = this.getQueue(interaction.guild.id);
    if (!queue.current) {
      return interaction.reply({ content: '‚ùå Aucune musique en cours !', ephemeral: true });
    }
    
    const embed = new EmbedBuilder()
      .setColor(0xE91E63)
      .setAuthor({ name: 'üìã File d\'attente', iconURL: interaction.guild.iconURL() })
      .setThumbnail(interaction.guild.iconURL())
      .addFields([
        { name: 'üéµ En cours', value: `${queue.current.title} - \`${queue.current.duration}\``, inline: false }
      ]);
    
    if (queue.tracks.length > 0) {
      const queueList = queue.tracks.slice(0, 10).map((track, i) => 
        `${i + 1}. ${track.title} - \`${track.duration}\``
      ).join('\n');
      
      embed.addFields([{ name: 'üìã Suivant(s)', value: queueList }]);
    }
    
    return interaction.reply({ embeds: [embed] });
  }
  
  formatDuration(seconds) {
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = seconds % 60;
    
    if (h > 0) return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    return `${m}:${s.toString().padStart(2, '0')}`;
  }

  // M√©thode pour jouer des fichiers locaux (playlists personnalis√©es)
  async playLocal(interaction, track, voiceChannel, isFirst = false) {
    const uploadsPath = path.join(__dirname, '../../data/uploads');
    const queue = this.getQueue(interaction.guild.id);
    
    let trackToAdd;
    
    // Support YouTube URLs ET fichiers locaux
    if (track.url && (track.url.includes('youtube') || track.url.includes('youtu.be'))) {
      // URL YouTube
      trackToAdd = {
        title: track.title || 'Sans titre',
        author: track.author || 'Artiste inconnu',
        url: track.url,
        duration: track.duration || '?:??',
        thumbnail: track.thumbnail || null,
        requestedBy: interaction.user,
        isLocal: false
      };
    } else if (track.filename) {
      // Fichier local
      trackToAdd = {
        title: track.title || track.filename || 'Musique locale',
        author: track.author || 'Playlist personnalis√©e',
        url: null,
        localPath: path.join(uploadsPath, track.filename),
        duration: track.duration || '?:??',
        thumbnail: track.thumbnail || null,
        requestedBy: interaction.user,
        isLocal: true
      };
    } else {
      console.error('[PlayLocal] Track invalide:', JSON.stringify(track));
      return;
    }
    
    queue.tracks.push(trackToAdd);
    queue.channel = interaction.channel;
    
    if (!queue.current && isFirst) {
      await this.processQueue(interaction.guild, voiceChannel);
    }
  }

}



module.exports = { CustomMusicManager };
